
		TOPPERS/HRP3カーネル
		ARMコア依存部 設計メモ

		対応バージョン: Release 3.0.0
		最終更新: 2018年4月16日

○メモの位置付け

このメモは，TOPPERS/HRPカーネルRelease 3（以下，HRP3カーネルと呼ぶ）の
ARMコア依存部の設計メモである．現時点では，記載の網羅度は低い．

○ソフトウェア割込みによるサービスコール呼出し（ARM用）

●機能コードの渡し方

svc命令には，ARMモードで24ビット，Thumbモードで8ビットの即値を渡すこと
ができるが，ARMモードに限定すればよいが，Thumbモードの8ビットでは機能コー
ドを入れるのに十分ではない．

そこで，svc命令の即値は，サービスコール呼出しであることを示す値
SVC_SERVICE_CALL（＝1）を入れることとし，サービスコール呼出しでない場合
には，DEF_EXCで登録したCPU例外ハンドラを呼ぶことにする．

機能コードは，いずれかのレジスタに入れて渡すことにする．どのレジスタに
入れるかは，パラメータの渡し方と合わせて検討する．

●パラメータの渡し方

サービスコール呼出しのオーバヘッドを最小限にするために，パラメータの移
動を最小限にするように工夫する．

HRP3カーネルでは，最もパラメータの多いサービスコールのパラメータ数は5で
あり，C言語で記述されたサービスコール本体は，パラメータを，r0，r1，r2，
r3，[sp]に入れて呼び出す．拡張サービスコール本体については，さらに，
cdmidを[sp, #4]に入れて呼び出す．

このことから，svc命令を発行する時点で，パラメータを，r0，r1，r2，r3，
r4に入れ，機能コードをr5に入れることとする．

●保存されるレジスタ／されないレジスタ

サービスコール呼出しですべてのレジスタが保存されるとする手もあるが，関
数呼出しの一般論に従えば，スクラッチレジスタは破壊されるとするのが素直
と考えられる．そこで，スクラッチレジスタ（r0〜r3，r12，lr）は壊れるもの
とする．

●SVCハンドラの入口

ASP3カーネルのSVCハンドラの入口に以下のコードを追加する．

--------------------
ALABEL(svc_handler)
	push	{r0}
	mrs		r0, spsr				/* 呼出し元のThumbモードビットをチェック */
	tst		r0, CPSR_THUMB_BIT
	ldrhne	r0, [lr,#-2]			/* Thumbモードから呼ばれた場合 */
	bicne	r0, r0, #0xff00
	ldreq	r0, [lr,#-4]			/* ARMモードから呼ばれた場合 */
	biceq	r0, r0, #0xff000000
	teq		r0, #SVC_SERVICE_CALL	/* サービスコール呼出しか？ */
	pop		{r0}
	beq		svc_entry
--------------------

○HRP3におけるARMv6のMMUの使い方

●方針

ARMv6の（新しい）アドレス変換機構を使用する（ARMv5への対応が必要な場合
は，別途考える）．TTBR0のみを用い，TTBR1は用いない．

レッドゾーン方式を採用し，タスク毎にユーザスタックへのアクセス権を切り
換える処理は行わない．

ユーザドメイン毎に変換テーブルを作る．ただし，ユーザドメインが1つもない
場合は，カーネルドメイン専用の変換テーブルを作る（変換テーブルがないと，
メモリ属性を制御できない）．

すべてスモールページ（4KB）を使うことを基本とするが，たまたま複数のペー
ジに渡って同じ属性の場合には，ラージページ（64KB）やセクション（1MB）を
用いる．

カーネルドメインのみがアクセスできるメモリ領域を1MB単位にアラインさせ，
セクション（1MB）で保護する方法も有力であり，将来的に検討するかもしれ
ない．

ドメインの機能は使用せず（理由は前述），すべてのメモリ領域をドメイン0に
属させ，ドメインアクセス制御レジスタは，ドメイン0に対してクライアントに
設定する．

●メモリオブジェクト属性

ターゲット非依存
TA_NOWRITE	0x01U	書込みアクセス禁止 → APで制御
TA_NOREAD	0x02U	読出しアクセス禁止 → 単独では制御できない
TA_EXEC		0x04U	実行アクセス許可 → XNで制御
TA_MEMINI	0x08U	メモリの初期化を行う → 関係なし
TA_MEMZERO	0x10U	メモリのクリアを行う → 関係なし
TA_SDATA	0x20U	ショートデータ領域に配置 → 無視する
TA_UNCACHE	0x40U	キャッシュ禁止 → TEX,C,Bで制御（001,0,0）
TA_IODEV	0x80U	周辺デバイスの領域 → TEX,C,Bで制御（000,0,1）
※ TA_NULLの場合 → TEX,C,Bは（001,1,1）

ターゲット依存
TA_WTHROUGH	0x100U	ライトスルーキャッシュ → TEX,C,Bで制御（000,0,1）
TA_SORDER	0x200U	ストロングオーダ → TEX,C,Bで制御（000,0,0）

競合するメモリオブジェクト属性の優先順位
・TA_SORDERがあれば，ストロングオーダに
・そうでなくて，TA_IODEVがあれば，周辺デバイス領域に
・そうでなくて，TA_UNCACHEがあれば，キャッシュ禁止に
・そうでなくて，TA_WTHROUGHがあれば，ライトスルーキャッシュに
・TA_WTHROUGHが弱いことに注意

制限事項
・外側と内側のキャッシュポリシーを別々に設定する方法はサポートしない
・ライトバック，no write allocateはサポートしない

その他
・TA_NOREADが指定されている場合は，警告とする
・acptn1で書込みが許可，acptn2で読出しが禁止の場合も，警告とする

●第1レベルテーブル（セクションテーブル）

TTBR0のみを使うことから，セクションテーブルのサイズは16KB（4Kエントリ）
に固定される．

#define SECTION_TABLE_SIZE	UINT_C(0x4000)
#define SECTION_TABLE_ALIGN	UINT_C(0x4000)
#define SECTION_TABLE_ENTRY	(SECTION_TABLE_SIZE / sizeof(uint32_t))

ユーザドメインがある場合
uint32_t section_table[TNUM_DOMID][SECTION_TABLE_ENTRY]
						__attribute__((aligned(SECTION_TABLE_ALIGN)));

ユーザドメインがない場合
uint32_t section_table[1][SECTION_TABLE_ENTRY]
						__attribute__((aligned(SECTION_TABLE_ALIGN)));

●第1レベルディスクリプタ

セクションテーブルのすべてのエントリを，まずは，0で初期化する（下位2ビッ
トが00なので，変換フォルトを起こす）．

第2レベルテーブル（コアースページテーブル）を参照するエントリは，次のよ
うに設定する．

	コアースページテーブルの設定（ARMV6_MMU_DSCR1_PAGETABLE）
	第2レベルテーブルのアドレスを設定
	Pビット（ECCが有効）はとりあえず0に設定
	属するドメインは0に設定

★Pビットについては，別途対処が必要になる可能性がある（ターゲット定義
のメモリリージョン属性にするなど）．

セクション全体にメモリアクセス属性を設定するエントリは，次のように設定
する．

	セクションの設定（ARMV6_MMU_DSCR1_SECTION）
	セクションのアドレスは，物理アドレス＝論理アドレスに設定
	Pビット（ECCが有効）はとりあえず0に設定
	他（nG，S，AP，TEX，XN，C，B）は，後述のスモールページと同様

●第2レベルテーブル（コアースページテーブル）

ページテーブルは，1MBのメモリ領域毎に1つ必要となるが，いくつのページテー
ブルを確保しておくかが問題になる．登録されたメモリリージョンをすべてス
モールページ（4KB）で設定した場合に必要となるページテーブルの数が基準と
なる．この基準値をコンフィギュレータで求めてMAX_DOM_PAGE_TABLEに定義し，
それに対するパーセンテージをユーザに定義させる（デフォルトは100%）．

ドメイン毎に確保しておくページテーブル数
#define MAX_DOM_PAGE_TABLE	xxx		/* ドメイン毎のページテーブル数の目安値 */
#ifndef PAGE_TABLE_RATIO
#define PAGE_TABLE_RATIO	100		/* ページテーブルの確保率 */
#endif /* PAGE_TABLE_RATIO */
#define PAGE_TABLE_NUM		(MAX_DOM_PAGE_TABLE * PAGE_TABLE_RATIO / 100)

#define PAGE_TABLE_SIZE		UINT_C(0x0400)
#define PAGE_TABLE_ALIGN	UINT_C(0x0400)
#define PAGE_TABLE_ENTRY	(PAGE_TABLE_SIZE / sizeof(uint32_t))

ユーザドメインがある場合
uint32_t page_table[TNUM_DOMID * PAGE_TABLE_NUM][PAGE_TABLE_ENTRY]
						__attribute__((aligned(PAGE_TABLE_ALIGN)));

ユーザドメインがない場合
uint32_t page_table[PAGE_TABLE_NUM][PAGE_TABLE_ENTRY]
						__attribute__((aligned(PAGE_TABLE_ALIGN)));


●第2レベルディスクリプタ

ページテーブルのすべてのエントリを，まずは，0で初期化する（下位2ビット
が00なので，変換フォルトを起こす）．

スモールページに対してメモリアクセス属性を設定するエントリは，次のよう
に設定する．

	スモールページの設定（ARMV6_MMU_DSCR2_SMALL）
	ページのアドレスは，物理アドレス＝論理アドレスに設定
	nGビットは次のように設定する
		acptn1とacptn2が，いずれもTACP_KERNELかTACP_SHAREDであれば，0に設定
		そうでなければ1に設定
	Sビットは次のように設定する
		TA_NONSHAREDであれば設定しない
		TA_NONSHAREDでなければ設定する（ARMV6_MMU_DSCR2_SHARED）
	APビットは次のように設定する
		TA_NOWRITEがあり，ユーザドメインからROであれば，AP＝111
		TA_NOWRITEがあり，ユーザドメインからアクセス不可であれば，AP＝101
		TA_NOWRITEがなく，ユーザドメインからR/Wであれば，AP＝011
		TA_NOWRITEがなく，ユーザドメインからROであれば，AP＝010
		TA_NOWRITEがなく，ユーザドメインからアクセス不可であれば，AP＝001
	TEXビット，Cビット，Bビットは次のように設定する
		TA_SORDERがあれば，（TEX,C,B）＝（000,0,0）
		そうでなくて，TA_IODEVがあれば，（TEX,C,B）＝（000,0,1）
		そうでなくて，TA_UNCACHEがあれば，（TEX,C,B）＝（001,0,0）
		そうでなくて，TA_WTHROUGHがあれば，（TEX,C,B）＝（000,1,0）
		そうでなければ，（TEX,C,B）＝（001,1,1）
	XNビットは次のように設定する
		TA_EXECであれば設定しない
		そうでなければ設定する（ARMV6_MMU_DSCR2S_NOEXEC）

ラージページに対してメモリアクセス属性を設定するエントリも，上と同様だ
が，同じエントリを16個続けて設定する．

○ドメイン機能の使用について

HRP3カーネルでドメインを使うアプローチは2つ考えられるが，いずれの場合
も1MB単位という制限が厳しく，実用的ではないと判断した．そこで，HRP3で
はドメイン機能は使わない（すべてのメモリ領域をドメイン0に属させる）こ
ととする．DACR（Domain Access Control Register）は，ドメイン0に対して
はTLBエントリのアクセス許可に従い（client），他のドメインに対してはア
クセスできないように設定する（他のドメインは使わないため，どのように設
定しても同じである）．

HRP3カーネルでドメインを使う2つのアプローチは，以下の通り．

アプローチ1）ARMドメインを，ユーザドメインを表すものとして使用する．最
も単純なケースでは，アドレス変換テーブルが1つだけで良くなるが，ユーザド
メイン間で共有するメモリ領域がある場合には，共有関係毎に別のARMドメイン
に属させる必要があり，ARMドメイン数が16個という制限が厳しくなる．また，
1MB単位という制限も厳しい．複数のアドレス変換テーブルとARMドメインを巧
妙に組み合わせる方法も考えられるが，複雑化するわりにメリットが少ないと
思われる．

アプローチ2）ARMドメインを用いて，ユーザドメイン内のタスクのユーザスタッ
ク領域を保護するために用いる．同じユーザドメイン内のユーザスタックを異
なるARMドメイン（1〜15を使用する）に属させ，タスク毎にドメインアクセス
制御レジスタを切り換えることで，ユーザスタック領域の保護を実現する．タ
スク数が15を越える場合には，ユーザスタック領域が離れた場所にあるタスク
で同じARMドメインを使用する手もある（保護は甘くなるが，レッドゾーン方式
よりは強い）．問題点は，ユーザスタック領域を1MB単位で割り当てなければな
らず，メモリの無駄が大きいことである．

以上
