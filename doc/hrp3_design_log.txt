
		TOPPERS/HRP3カーネル
		設計メモ

		対応バージョン: Release 3.1.0
		最終更新: 2019年1月2日

このドキュメントは，TOPPERS/HRPカーネルRelease 3（以下，HRP3カーネルと
呼ぶ）の設計記録である．TOPPERS/ASPカーネルRelease 3（以下，ASP3カーネ
ル）からの拡張作業について記載している．現時点では，すべての設計事項を
網羅できていない．

----------------------------------------------------------------------
 TOPPERS/HRP3 Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     High Reliable system Profile Kernel

 Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: hrp3_design_log.txt 631 2019-01-02 09:20:29Z ertl-hiro $
----------------------------------------------------------------------

○目次

・HRP3カーネルの仕様
・データ型，定数，マクロの定義
	- アクセス許可パターンとアクセス許可ベクタ
	- 保護ドメインID
・ユーザタスクの実現
	- ユーザタスクとシステムタスクの区別
	- スタック領域のサイズと先頭番地
	- システムタスクのスタック領域の生成とエラーチェック
	- ユーザタスクのシステムスタック領域の生成とエラーチェック
	- ユーザタスクのユーザスタック領域の生成とエラーチェック
	- ユーザスタックポインタの保存と復帰
	- ユーザタスクの起動
	- ディスパッチャの動作開始
	- ユーザスタック領域のアクセス保護
・保護ドメインの管理
	- 保護ドメイン初期化ブロック
	- オブジェクトのアクセス許可ベクタの管理
	- タスク以外のオブジェクトの属する保護ドメインの管理
	- 実行中の保護ドメインの管理
	- svclevelの導入
	- rundomの設定方法
	- オブジェクトに対するアクセス権チェックの追加
	- 通知ハンドラの生成時におけるアクセス権チェックの追加
	- メモリ領域のアクセス保護
	- 実行状態のタスクの属する保護ドメインIDの参照
	- 拡張サービスコールを呼び出した保護ドメインの参照
・ユーザタスクが特権モードを実行しているか否かの判別
	- ターゲット非依存に判別する方法の難しさ
	- 特権モードを実行しているか否かを判別する関数
・サービスコールの呼出し処理
	- サービスコール処理関数のリネーム
	- 関数呼出しによるサービスコール呼出し
	- ソフトウェア割込みによるサービスコール呼出し
	- ソフトウェア割込みの出入口処理
	- 拡張サービスコールの管理と出入口処理
・CPU例外発生時の状態参照機能の修正
・保護ドメインのメモリ管理
	- 用語に関する注意
	- メモリオブジェクトの管理
	- メモリオブジェクト初期化ブロック
	- メモリオブジェクト初期化ブロックの探索
	- ユーザスタック領域に含まれているかのチェック
	- メモリアクセス権のチェック
	- メモリアクセス権のチェックマクロ
	- メモリアクセス権チェックの追加
	- prb_memの実装
	- メモリアクセス違反ハンドラの実装
・メモリオブジェクトの登録と配置
	- 登録すべきメモリオブジェクト
	- 標準的なメモリオブジェクト属性
	- 配置先メモリリージョン，保護ドメイン，属性，アクセス許可ベクタ
	- メモリオブジェクトの統合
	- タスクのユーザスタック領域の扱い
	- 固定長メモリプール領域の扱い
	- 用語の整理
	- メモリオブジェクトの配置順序
	- ROMリージョンにおけるメモリ保護単位の配置順序
	- RAMリージョンにおけるメモリ保護単位の配置順序
	- メモリ保護単位内での配置順序
	- メモリオブジェクトの配置順序の実装
	- レッドゾーン方式におけるユーザスタック領域の配置順序の決定（★未完成）
	- メモリオブジェクト／セクション／メモリ保護単位のラベル
	- dataセクションとbssセクションの初期化
・コンフィギュレーション処理手順
・時間パーティショニングのベース時刻／時間とタイマの使い方
	- システム周期とタイムウィンドウのベース時刻／時間
	- 時間パーティショニング実現のためのタイマの使い方
	- 参考：高分解能タイマとオーバランタイマの統合が難しい理由
	- タイムウィンドウタイマの操作と割込み処理
・時間パーティショニング下でのタスクスケジューリング
	- スケジューリング単位
	- 実行すべきタスクの更新
	- タイムウィンドウタイマの動作開始／停止タイミング
	- タイムウィンドウタイマの動作開始／停止処理コード
・システム周期とタイムウィンドウの管理
	- システム周期切換え処理と実行開始処理
	- タイムウィンドウ切換え処理
	- タイムウィンドウの実行開始処理
	- ユーザドメインに属するタイムイベントの処理
	- ユーザドメインに属するタイムイベントの処理コード
	- システム周期切換えとタイムウィンドウ切換えの保留

○HRP3カーネルの仕様

HRP3カーネルは，TOPPERS/ASP3カーネルに対して，メモリ保護機能とオブジェ
クトアクセス保護機能，時間パーティショニング機能，拡張サービスコール機
能を追加したものである．また，ASP3カーネルでは拡張パッケージでサポート
していたメッセージバッファ機能を，標準でサポートしている．HRP2カーネル
で標準機能としていたオーバランハンドラ機能は，拡張パッケージでサポート
する（現時点では未サポート）．

HRP3カーネルの仕様は，TOPPERS第3世代カーネル（ITRON系）統合仕様に記述さ
れている．詳細な仕様については，TOPPERS第3世代カーネル（ITRON系）統合仕
様書を参照すること．

○データ型，定数，マクロの定義

●アクセス許可パターンとアクセス許可ベクタ

ASP3カーネルのt_stddef.hには，アクセス許可パターンとアクセス許可ベクタ
のためのデータ型，定数，マクロの定義を含んでいるため，HRP3カーネル向け
に追加する必要はない（t_stddef.hはカーネルによらず共通にする方針）．

●保護ドメインID

保護ドメインIDを，以下のように定義する（kernel.h）．

----------------------------------------
#define TDOM_SELF		0				/* 自タスクの属する保護ドメイン */
#define TDOM_KERNEL		(-1)			/* カーネルドメイン */
#define TDOM_NONE		(-2)			/* 無所属（保護ドメインに属さない）*/
----------------------------------------

○ユーザタスクの実現

●ユーザタスクとシステムタスクの区別

TCBまたはそこからリンクされたデータ構造を参照することで，ユーザタスク
とシステムタスクを区別できることが必要である．

これを実現するために，TCBに保護ドメイン初期化ブロックを指すポインタを
入れる（task.h）．

----------------------------------------
struct task_control_block {
	………
+	const DOMINIB	*p_dominib;		/* 保護ドメイン初期化ブロック */
	………
};
----------------------------------------

タスクがシステムタスクであるかは，p_dominibがカーネルドメインの保護ド
メイン初期化ブロックを指しているか，または，p_dominib->domptn（後述）
がTACP_KERNELであるかで判別することができる．

TCBのp_dominibフィールドを初期化するために，タスク初期化ブロックに保護
ドメインIDを入れる（値はコンフィギュレータが設定する）．

----------------------------------------
typedef struct task_initialization_block {
+	ID			domid;			/* 保護ドメインID */
	………
} TINIB;
----------------------------------------

タスク初期化ブロックに，p_dominibではなく保護ドメインIDを入れるのは，
get_didの実装に必要なためである．

●スタック領域のサイズと先頭番地

タスク初期化ブロック中に持っているスタック領域のサイズと先頭番地を，シ
ステムスタック領域のサイズと先頭番地と，ユーザスタック領域のサイズと先
頭番地に分離する（task.h）．

----------------------------------------
typedef struct task_initialization_block {
	………
#ifdef USE_TSKINICTXB
	TSKINICTXB	tskinictxb;		/* タスク初期化コンテキストブロック */
#else /* USE_TSKINICTXB */
!	SIZE	sstksz;				/* システムスタック領域のサイズ（丸めた値） */
!	void	*sstk;				/* システムスタック領域の先頭番地 */
!	SIZE	ustksz;				/* ユーザスタック領域のサイズ（丸めた値） */
!	void	*ustk;				/* ユーザスタック領域の先頭番地 */
#endif /* USE_TSKINICTXB */
	………
} TINIB;
----------------------------------------

システムタスクの場合には，sstkszとsstkを用い，ustkszとustkは用いない．
これは，CRE_TSKのパラメータの扱いとは異なるが，システムタスクとユーザタ
スクで，カーネルが用いるスタック領域を同じフィールドから初期化できる方
が見透しがよいと考えたためである．コンフィギュレータは，システムタスク
に対しては，ustkszに0，ustkにNULLを設定するものとする．

上記のスタック領域のサイズと先頭番地の持ち方は，ターゲットプロセッサに
依存しない汎用的な方法であるが，ターゲットプロセッサによっては，より効
率的な持ち方がある場合がある．また，ターゲット依存の情報をタスク初期化
ブロックに入れたい場合もある．そこで，このような場合には，ターゲット依
存部（target_kernel_impl.h）で，USE_TSKINICTXBをマクロ定義し，TINIB中
に持つことが必要なデータを入れるためのタスク初期化コンテキストブロック
（TSKINICTXB型）を定義することとする．

タスク初期化ブロックのテーブルは，コンフィギュレータで生成する．タスク
初期化コンテキストブロックの初期化記述は，パス2の生成スクリプトのター
ゲット依存部で，関数GenerateTskinictxbに定義する．GenerateTskinictxbに
は，タスクのID番号（数値）とパラメータ情報（ハッシュ）がパラメータとし
て渡される．USE_TSKINICTXBを定義しない場合には，タスク初期化コンテキス
トブロックを生成せず，汎用のタスク初期化ブロックを生成する．

●システムタスクのスタック領域の生成とエラーチェック

システムタスクのスタック領域の生成とエラーチェックは，コンフィギュレー
タのパス2およびチェックパス（自動メモリ配置の場合はパス4，手動メモリ配
置の場合はパス3）で，次の手順で行う．

	sstkにNULL以外を指定した場合 → E_PAR［NGKI1068］
	stkszが0の場合 → E_PAR［NGKI1042］
	stkが省略されているか，NULLの場合
		sstkszに0以外の値を指定した場合
			stksz+sstkszがターゲット定義の最小値より小さい場合
														→ E_PAR［NGKI1042］
			stksz+sstkszのサイズのスタック領域を確保［NGKI1069］［NGKI1049］
			→ タスク初期化ブロックのsstksz，sstkに設定［NGKI1041］
		sstkszが省略されているか，0を指定した場合［NGKI1072］
			stkszがターゲット定義の最小値より小さい場合 → E_PAR［NGKI1042］
			stkszのサイズのシステムスタック領域を確保［NGKI1049］
			→ タスク初期化ブロックのsstksz，sstkに設定［NGKI1041］
	stkがNULLでない場合
		sstkszに0以外の値を指定した場合 → E_PAR［NGKI1071］
		stkszがターゲット定義の最小値より小さい場合 → E_PAR［NGKI1042］
		stkszがターゲット定義のスタック領域のサイズの制約を
									満たしていない場合 → E_PAR［NGKI1056］
		〔手動メモリ配置の場合〕stkがターゲット定義のスタック領域の
					先頭番地の制約を満たしていない場合 → E_PAR［NGKI1056］
		→ タスク初期化ブロックのsstksz，sstkに設定［NGKI1041］

	〔チェックパスで検出〕
		stkがターゲット定義のスタック領域の先頭番地の制約を
									満たしていない場合 → E_PAR［NGKI1056］
		スタック領域がカーネル専用のメモリオブジェクトに
									含まれていない場合 → E_OBJ［NGKI1057］

ここで，スタック領域のサイズのターゲット定義の最小値は，ターゲット依存
部（target_kernel_impl.h）で，TARGET_MIN_SSTKSZに定義する．
TARGET_MIN_SSTKSZを定義しない場合，スタック領域のサイズが0以下の場合に
のみE_PARエラーとなる．つまり，TARGET_MIN_SSTKSZを1に定義したのと同等
となる（ASP3カーネルのTARGET_MIN_STKSZを，TARGET_MIN_SSTKSZにリネーム）．

スタック領域のサイズ（stksz）が，ターゲット定義の制約を満たしているか
のチェックを行うには，スタック領域のサイズのアライン単位を，ターゲット
依存部（target_kernel_impl.h）で，CHECK_SSTKSZ_ALIGNに定義する（ASP3カー
ネルのCHECK_STKSZ_ALIGNを，CHECK_SSTKSZ_ALIGNにリネーム）．

スタック領域の先頭番地（stk）が，ターゲット定義の制約を満たしているか
のチェックを行うには，スタック領域の先頭番地のアライン単位を，ターゲッ
ト依存部（target_kernel_impl.h）で，CHECK_SSTACK_ALIGNに定義する（ASP3
カーネルのCHECK_STACK_ALIGNを，CHECK_SSTACK_ALIGNにリネーム）．また，
スタック領域の先頭番地（stk）がNULLでないことをチェックするには，ター
ゲット依存部（target_kernel_impl.h）で，CHECK_STACK_NONNULLを定義する
（ASP3カーネルと同じ）．

スタック領域をコンフィギュレータによって確保する方法はターゲット依存に
なる場合があるため，スタック領域を確保するための記述を生成する記述は，
必要であれば，パス2の生成スクリプトのターゲット依存部で，関数
AllocSystemStackに定義する．ターゲット依存部でAllocSystemStackが定義さ
れていない場合には，ターゲット非依存部でデフォルトの定義を行う（ASP3カー
ネルのAllocStackを，AllocSystemStackにリネーム）．

なお，システムタスクに対しては，タスク初期化ブロック中のustksz，ustkは
使わないため，ustkszには0，ustkにはNULLを設定する．

●ユーザタスクのシステムスタック領域の生成とエラーチェック

ユーザタスクのシステムスタック領域の生成とエラーチェックは，コンフィギュ
レータのパス2およびチェックパスで，次の手順で行う．

	sstkが省略されているか，NULLの場合
		sstkszが省略されていない場合
			sstkszがターゲット定義の最小値より小さい場合 → E_PAR［NGKI1044］
			sstkszのサイズのシステムスタック領域を確保［NGKI1061］
			→ タスク初期化ブロックのsstksz，sstkに設定［NGKI1043］
		sstkszが省略されている場合
			DEFAULT_SSTKSZのサイズのシステムスタック領域を確保［NGKI1063］
			→ タスク初期化ブロックのsstksz，sstkに設定［NGKI1043］
	sstkがNULLでない場合
		sstkszが省略されている場合 → エラー
		sstkszがターゲット定義の最小値よりも小さい場合 → E_PAR［NGKI1044］
		sstkszがターゲット定義のスタック領域のサイズの制約を
									満たしていない場合 → E_PAR［NGKI1065］
		→ タスク初期化ブロックのsstksz，sstkに設定［NGKI1043］

	〔チェックパスで検出〕
		sstkがターゲット定義のスタック領域の先頭番地の制約を
									満たしていない場合 → E_PAR［NGKI1065］
		システムスタック領域がカーネル専用のメモリオブジェクトに
									含まれていない場合 → E_OBJ［NGKI1066］

ここで，ユーザタスクのシステムスタック領域のサイズの記述が省略された場
合のデフォルトのサイズは，ターゲット依存部（target_kernel_impl.h）で
DEFAULT_SSTKSZに定義する．DEFAULT_SSTKSZの定義は必須である．

システムスタック領域のサイズのターゲット定義の最小値
（TARGET_MIN_SSTKSZ），システムスタック領域のサイズのアライン単位
（CHECK_SSTKSZ_ALIGN），システムスタック領域の先頭番地のアライン単位
（CHECK_SSTACK_ALIGN），システムスタック領域の先頭番地がNULLでないこと
をチェックするか（CHECK_STACK_NONNULL）の設定は，システムスタックのス
タック領域に対する設定と共用している．また，システムスタック領域を確保
するための記述を生成するための生成スクリプトの関数AllocSystemStackも，
システムスタックのスタック領域を確保する関数と共用している．

●ユーザタスクのユーザスタック領域の生成とエラーチェック

ユーザタスクのユーザスタック領域の生成とエラーチェックは，コンフィギュ
レータのパス2およびチェックパス等で，次の手順で行う．

	stkszがターゲット定義の最小値よりも小さい場合 → E_PAR［NGKI1042］
	stkが省略されているか，NULLの場合
		手動メモリ配置の場合 → E_PAR［NGKI3907］
		stkszのサイズのユーザスタック領域を確保［NGKI1049］
		→ タスク初期化ブロックのustksz，ustkに設定［NGKI1041］
	stkがNULLでない場合
		stkszがターゲット定義のスタック領域のサイズの制約を
									満たしていない場合 → E_PAR［NGKI1056］
		〔手動メモリ配置の場合〕stkがターゲット定義のスタック領域の
					先頭番地の制約を満たしていない場合 → E_PAR［NGKI1056］
		→ タスク初期化ブロックのustksz，ustkに設定［NGKI1041］

	〔チェックパスで検出〕
		stkがターゲット定義のスタック領域の
					先頭番地の制約を満たしていない場合 → E_PAR［NGKI1056］

	〔自動メモリ配置の時はパス4，手動メモリ配置の時はパス2で検出〕
		ユーザスタック領域が他のメモリオブジェクトと
								オーバラップしている場合 → E_OBJ［NGKI1060］

ここで，ユーザスタック領域のサイズのターゲット定義の最小値は，ターゲッ
ト依存部（target_kernel_impl.h）で，TARGET_MIN_USTKSZに定義する．
TARGET_MIN_USTKSZを定義しない場合，ユーザスタック領域のサイズが0以下の
場合にのみE_PARエラーとなる．つまり，TARGET_MIN_USTKSZを1に定義したの
と同等となる．

ユーザスタック領域のサイズ（stksz）が，ターゲット定義の制約を満たして
いるかのチェックを行うには，ユーザスタック領域のサイズのアライン単位を，
ターゲット依存部（target_kernel_impl.h）で，CHECK_USTKSZ_ALIGNに定義す
る．

スタック領域の先頭番地（stk）が，ターゲット定義の制約を満たしているか
のチェックを行うには，スタック領域の先頭番地のアライン単位を，ターゲッ
ト依存部（target_kernel_impl.h）で，CHECK_USTACK_ALIGNに定義する．また，
スタック領域の先頭番地（stk）がNULLでないことをチェックするには，ター
ゲット依存部（target_kernel_impl.h）で，CHECK_STACK_NONNULLを定義する
（システムタスクのスタック領域の先頭番地に対する設定と共用）．

ユーザスタック領域が，他のメモリオブジェクトとオーバラップしていないか
のチェックは，自動メモリ配置の時はコンフィギュレータのパス4，手動メモ
リ配置の時はパス2で行う．ただし，同じユーザドメインに属するタスクのユー
ザスタック領域については，複数のタスクで同一のユーザスタック領域を使用
することを，ターゲット定義で許す方法を用意する．

ユーザスタック領域をコンフィギュレータによって確保する方法はターゲット
依存になるため，ユーザスタック領域を確保するための記述を生成する記述は，
パス2の生成スクリプトのターゲット依存部で，関数AllocUserStackに定義す
る．AllocUserStackは，ターゲット依存部で，必ず定義しなければならない
（デフォルトの定義がない）．

●ユーザスタックポインタの保存と復帰

システムスタックとユーザスタックを分離したことに伴い，ユーザスタックポ
インタの保存／復帰を行う必要がある．

ユーザスタックポインタの保存／復帰を行う方法として，次の2つの方法がある．

(a) タスクディスパッチャにおいて保存／復帰する．
(b) 特権モードに遷移する箇所で保存し，非特権モードに戻る箇所で復帰する．

特権モード用のスタックと非特権モード用のスタックを別々に持つターゲット
プロセッサでは(a)の方法が，別々に持たないターゲットプロセッサでは(b)の
方法が素直である．(b)の方法を採用する場合には，ユーザスタックポインタを
TSKCTXB中またはシステムスタック上に保存する．

以下では，(a)の方法を仮定して設計を進めるが，ターゲット依存で(b)の方法
を選択してもよい．以下で疑似コード中で単に「スタック」と記述した場合に
は，その時点で使用しているスタックを指すものとする．

また，システムスタックとユーザスタックを分離したことにより，割込みと
CPU例外の出入口で，スタックの切換えを行う必要がある．ターゲットプロセッ
サによっては，この切換え処理はハードウェアによって行われるため，ソフト
ウェアで行う必要はない．

----------------------------------------
void
dispatch(void)
{
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_stop();					/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	スクラッチレジスタを除くすべてのレジスタをスタックに保存する
+	if (自タスクがユーザタスク) {
+		ユーザスタックポインタをスタックに保存する
+	}
	スタックポインタを自タスク（p_runtsk）のTCBに保存する
	dispatch_rを，実行再開番地として自タスクのTCBに保存する
	dispatcherに分岐する

  dispatch_r:
+	if (自タスクがユーザタスク) {
+		ユーザスタックポインタをスタックから復帰する
+	}
	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
}
----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともカーネル管理の割込みを禁止した状態にする
+	if (非特権モードで割込み発生) {
+		スタックを実行状態のタスクのシステムスタックに切り換える
+	}
	スクラッチレジスタをスタックに保存する

	………

	if (割込みがタスクコンテキストで発生) {
		………

		if (p_runtsk != p_schedtsk) {
			CPUロック状態にする
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない
			スクラッチレジスタを除くすべてのレジスタをスタックに保存する
+			if (自タスクがユーザタスク) {
+				ユーザスタックポインタをスタックに保存する
+			}
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する
			dispatcherに分岐する

		  ret_int_r:
+			if (自タスクがユーザタスク) {
+				ユーザスタックポインタをスタックから復帰する
+			}
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
		}
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	}
	割込み処理からのリターンにより，CPUロック解除状態に戻るように準備する
	スクラッチレジスタをスタックから復帰する
+	if (戻り先が非特権モード) {
+		スタックを実行状態のタスクのユーザスタックに戻す
+	}
	割込み処理からのリターン
}
----------------------------------------
void
<CPU例外の出入口処理>(void)
{
+	if (非特権モードでCPU例外発生) {
+		スタックを実行状態のタスクのシステムスタックに切り換える
+	}
	スクラッチレジスタをスタックに保存する
	CPU例外が発生した状況を判断するための追加情報をスタックに保存する

	………

		if (CPU例外がタスクコンテキストで発生) {
			………

			if (p_runtsk != p_schedtsk) {
				CPUロック状態にする
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない
				スクラッチレジスタを除くすべてのレジスタをスタックに保存する
+				if (自タスクがユーザタスク) {
+					ユーザスタックポインタをスタックに保存する
+				}
				スタックポインタを自タスク（p_runtsk）のTCBに保存する
				ret_exc_rを，実行再開番地として自タスクのTCBに保存する
				dispatcherに分岐する

			  ret_exc_r:
+				if (自タスクがユーザタスク) {
+					ユーザスタックポインタをスタックから復帰する
+				}
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_start();		/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
		}
		CPU例外処理からのリターン後に，CPUロック解除状態に戻るように準備する
	}
	CPU例外が発生した状況を判断するための追加情報をスタック上から捨てる
	スクラッチレジスタをスタックから復帰する
+	if (戻り先が非特権モード) {
+		スタックを実行状態のタスクのユーザスタックに戻す
+	}
	CPU例外処理からのリターン
}
----------------------------------------

上記のコードでは，ユーザタスクに対してのみユーザスタックポインタの保存／
復帰を行っているが，ユーザタスクであることの判定が面倒な場合には，すべ
てのタスクに対して一律ユーザスタックポインタの保存／復帰を行っても差し
支えない（ターゲットによっては，これが許されない場合があるかもしれな
い）．

また，上記のコードでは，レジスタを保存した後にユーザスタックポインタを
保存し，その逆順で復帰しているが，これらの順序は変更しても差し支えない．

ユーザスタックポインタの保存／復帰をディスパッチャ本体（dispatcher）で
行う方法は，カーネル起動時，タスクの実行開始時，自タスクの終了時が例外
となるため，採用しなかった．

●ユーザタスクの起動

タスクの実行開始時の処理内容は，システムタスクとユーザタスクで大きく異
なる．そこで，システムタスク用のstart_stask_rと，ユーザタスク用の
start_utask_rを用意して，どちらを使うかをタスクの起動時に設定する．

----------------------------------------
void
activate_context(TCB *p_tcb)
{
	指定されたタスク（p_tcb）のTCB中のスタックポインタを初期化する
+	if (指定されたタスクがユーザタスク) {
+		start_utask_rを，実行再開番地として自タスクのTCBに保存する
+	}
+	else {
!		start_stask_rを，実行再開番地として自タスクのTCBに保存する
+	}
	return;

! start_stask_r:
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	CPUロック解除状態にする
	自タスク（p_runtsk）の起動番地を，拡張情報をパラメータとして呼び出す
	ext_tskに分岐する

+ start_utask_r:
+#ifdef TOPPERS_SUPPORT_OVRHDR
+	ovrtimer_start();					/* オーバランタイマの動作開始 */
+#endif /* TOPPERS_SUPPORT_OVRHDR */
+	自タスクのユーザスタックポインタを初期化する
+	例外／割込みからのリターンによって，
+			自タスクの起動番地へ分岐するように準備する … (*1)
+	例外／割込みからのリターンによって，非特権モード・CPUロック解除状態・
+			割込み優先度マスク全解除状態になるように準備する … (*2)
+	自タスクの起動番地へ分岐する際に，
+			自タスクの拡張情報がパラメータとして渡るように準備する … (*3)
+	自タスクの起動番地からのリターンにより，
+			call_ext_tskの番地へ分岐するように準備する … (*4)
+	例外／割込みからのリターン
}
----------------------------------------

システムタスク用のstart_stask_rは，名前を変えただけで，ASP3カーネルの
start_rと同じ内容である．

自タスクのユーザスタックポインタの初期値は，USE_TSKINICTXBを定義しない
場合には，ターゲットプロセッサにも依存するが，多くの場合に次の式で求め
ることができる．

	((char *)(p_runtsk->p_tinib->ustk) + p_runtsk->p_tinib->ustksz)

(*1)は，例外／割込みからのリターン先の番地を保持する領域（スタック上や
専用レジスタ）に，自タスクの起動番地を格納することで行う．(*2)は，例外／
割込みからのリターン後のシステム状態を保持する領域（スタック上や専用レ
ジスタ）に，非特権モード・CPU ロック解除状態・割込み優先度マスク全解除
状態を示す値を設定することで行う．また，これらのシステム状態の管理に変
数を用いている場合には，それらの変数の値を設定する．

(*3)は，例外／割込みからのリターン後に実行される関数のパラメータを置く
領域（ユーザスタック上や汎用レジスタ）に，自タスクの拡張情報を格納する
ことで行う．(*4)は，例外／割込みからのリターン後に実行される関数からの
リターン先番地を置く領域（ユーザスタック上や専用レジスタ）に，
call_ext_tskの番地を格納することで行う．

(*1)〜(*4)は，ターゲットプロセッサに都合のよい順序に並べ換えてよい．

call_ext_tskは，以下の内容の関数で，すべての保護ドメインから呼び出せる
共有ライブラリとして（よって，ext_tskとext_kerを，ソフトウェア割込みを
用いて呼び出すコードとしなければならない），ターゲット依存部で用意する．

----------------------------------------
void
call_ext_tsk(void)
{
	(void) ext_tsk();
	(void) ext_ker();
	assert(0);
}
----------------------------------------

ここで，ext_tskの後にext_kerを呼び出すのは，call_ext_tskが非タスクコン
テキストから呼ばれた場合の対策である．非タスクコンテキストはカーネルド
メインなので，ext_kerがエラーになることはない（はずである）．

●ディスパッチャの動作開始

ディスパッチャの動作開始処理（start_dispatch）は，切り換え先のスタック
を，システムスタック領域に修正する必要がある．

----------------------------------------
void
start_dispatch(void)
{
	タスクコンテキストに切り換える
!	スタックをIDが1のタスクのシステムスタック領域に切り換える
	CPUロック状態・割込み優先度マスク全解除状態にする
	dispatcher_0に分岐する
}
----------------------------------------

●ユーザスタック領域のアクセス保護

※この節の内容は，メモリ保護の方式を決定した後に実施すべきである．

タスクのユーザスタック領域を同じ保護ドメインに属する他のタスクから保護
する場合には（ターゲット定義で省略できる仕様となっている［NGKI0441］），
タスク切換えの際に，切換え前のタスクのユーザスタック領域をアクセスでき
ない状態とし，切換え後のタスクのユーザスタック領域をアクセスできる状態
とする必要がある．

切換え前のタスクのユーザスタック領域をアクセスできない状態とする処理と，
切換え後のタスクのユーザスタック領域をアクセスできる状態とする処理は，
ディスパッチャ本体に組み込む．

----------------------------------------
void
dispatcher(void)
{
#ifdef LOG_DSP_ENTER
	log_dsp_enter(p_runtsk);
#endif /* LOG_DSP_ENTER */
+	if (自タスクがユーザタスク) {
+		自タスクのユーザスタック領域をアクセスできない状態とする
+	}

  dispatcher_0:
	p_runtsk = p_schedtsk;
	if (p_runtsk != NULL) {
		自タスク（p_runtsk）のTCBからスタックポインタを復帰する
+		if (自タスクがユーザタスク) {
+			自タスクのユーザスタック領域をアクセスできる状態とする
+		}
#ifdef LOG_DSP_LEAVE
		log_dsp_leave(p_runtsk);
#endif /* LOG_DSP_LEAVE */
		自タスクのTCBから実行再開番地を復帰し，そこへ分岐する … (*a)
	}
	………
}
----------------------------------------

メモリプロテクションユニット（MPU）を持つターゲットプロセッサでは，切換
え後のタスクのユーザスタック領域をアクセスできる状態とすれば，切換え前
のタスクのユーザスタック領域はアクセスできなくなる場合が多い．この場合
には，アクセスできない状態とする処理は省略することができる．また，処理
内容を工夫することで，自タスクがユーザタスクか否かの判定は省ける場合が
ある．

ここで，自タスクのユーザスタック領域をアクセスできない状態とする処理は，
実行状態のタスクが終了する時（exit_and_dispatchからディスパッチャ本体に
入る場合）には行う必要があるが，カーネル起動時（start_dispatchからディ
スパッチャ本体に入る場合）には行う必要がない．exit_and_dispatchからは
dispatcherに分岐し，start_dispatchからはdispatcher_0に分岐するため，上
記のコードでこれが実現されている．

メモリ管理ユニット（MMU）を持つターゲットプロセッサでは，タスク毎にユー
ザスタック領域のアクセス権を切り換えると，効率が極めて低下する場合が多
い．その場合には，タスク毎にアクセス権を切り換えるのをやめ（統合仕様書
2.11.6節で明示的に許されている），レッドゾーン方式のユーザスタック領域
保護を採用する．

○保護ドメインの管理

●保護ドメイン初期化ブロック

HRP3カーネルでは，保護ドメインを管理するための動的な情報は必要ないため，
保護ドメインコントロールブロックは設けず，保護ドメイン初期化ブロックの
みを設ける．

保護ドメイン初期化ブロックには，次の情報を入れる（アクセス許可ベクタと
時間パーティショニングを実現するための情報は，後で追加する）．

　・保護ドメインのビットパターン（ACPTN型，カーネルドメインの場合は0）
　・設定できるタスク優先度の最小値（統合仕様書の「指定できる最高のタス
	ク優先度」，LMT_DOMで設定する）
　・ターゲット依存の情報（必要な場合のみ）

ターゲット依存の情報を入れる場合には，ターゲット依存部
（target_kernel_impl.h）で，USE_DOMINICTXBをマクロ定義し，ターゲット依
存の情報を入れるための保護ドメイン初期化コンテキストブロックの型
（DOMINICTXB）を定義する．

----------------------------------------
typedef struct domain_initialization_block {
	ACPTN		domptn;			/* 保護ドメインのビットパターン */
	uint_t		minpriority;	/* 設定できるタスク優先度の最小値 */
#ifdef USE_DOMINICTXB
	DOMINICTXB	dominictxb;		/* 保護ドメイン初期化コンテキストブロック */
#endif /* USE_DOMINICTXB */
} DOMINIB;
----------------------------------------

ユーザドメインの保護ドメイン初期化ブロックのテーブルは，コンフィギュレー
タで生成する．ユーザドメインの保護ドメイン初期化コンテキストブロックの
初期値を生成する記述は，パス2の生成スクリプトのターゲット依存部で，関
数GenerateDominictxbに定義する．GenerateDominictxbには，保護ドメインの
ID番号（数値）とパラメータ情報（ハッシュ）がパラメータとして渡される．

カーネルドメインの保護ドメイン初期化ブロックは，内容が変わらないためカー
ネル内で静的に定義する方法もあるが，そのためだけにdomain.cを用意するこ
とになることから，コンフィギュレータで生成することとする．カーネルドメ
インの保護ドメイン初期化コンテキストブロックの初期化記述は，パス2の生
成スクリプトのターゲット依存部で，変数kernelDominictxbに設定する．

●オブジェクトのアクセス許可ベクタの管理

保護の対象となるカーネルオブジェクトの初期化ブロックに，アクセス許可ベ
クタを追加する．

----------------------------------------
typedef struct task_initialization_block {
	………
	ACVCT		acvct;			/* アクセス許可ベクタ */
} TINIB;
----------------------------------------
typedef struct semaphore_initialization_block {
	………
	ACVCT		acvct;			/* アクセス許可ベクタ */
} SEMINIB;
----------------------------------------
※ 他の初期化ブロック（FLGINIB，DTQINIB，PDQINIB，MTXINIB，MBFINIB，
MPFINIB，CYCINIB，ALMINIB）も同様．
----------------------------------------

また，保護ドメイン初期化ブロックにも，アクセス許可ベクタを追加する．

----------------------------------------
typedef struct domain_initialization_block {
	………
+	ACVCT		acvct;			/* アクセス許可ベクタ */
} DOMINIB;
----------------------------------------

さらに，システム状態に対するアクセス許可ベクタを格納する変数を新設する
（kernel_impl.h）．

----------------------------------------
/*
 *  システム状態に対するアクセス許可ベクタ（kernel_cfg.c）
 */
extern const ACVCT	sysstat_acvct;
----------------------------------------

これらのアクセス許可ベクタの定義は，コンフィギュレータで生成する．

●タスク以外のオブジェクトの属する保護ドメインの管理

HRP3カーネルでは，タスク以外のオブジェクトに関しては，各カーネルオブジェ
クトに対してアクセス許可ベクタを管理すれば，それが属する保護ドメインを
取り出す必要がない．そのため，オブジェクト（タスク以外）の属する保護ド
メインに関する情報は管理しないことにする．

●実行中の保護ドメインの管理

アクセス権のチェックを行う際には，実行中の処理単位の属する保護ドメイン
（以下，単に実行中の保護ドメインという）のビットパターンを取り出すこと
が必要になる．実行中の保護ドメインは，次の方法で求めることができる．

タスクが拡張サービスコールを実行していない時には，実行中の保護ドメイン
は，そのタスクの属する保護ドメイン（ビットパターンは，
p_runtsk->p_dominib->domptn）である．非タスクコンテキスト実行中と，タス
クが拡張サービスコールを実行している時は，実行中の保護ドメインは，カー
ネルドメイン（ビットパターンは，TACP_KERNEL）である．

タスクが拡張サービスコールを実行しているか否かを判別する方法については，
次の節で検討することとし，ここでは，実行中の保護ドメインのビットパター
ンを管理する方法について検討する．

(1) 特別な変数等を設けず，毎回上記の方法によって求める．

この方法は，アクセス権チェックの度（TLBミス時にも，アクセス権チェックを
することに注意）に，条件分岐とポインタをたどる操作が必要になり，オーバ
ヘッドが大きいと思われる．

(2) 実行中の保護ドメインのビットパターンを保持する変数としてrundomを設
ける．

この方法にはさらに次のバリエーションが考えられる．

(2-1) rundomはタスクコンテキストでのみ有効な変数とする．

HRP2では，タスクコンテキスト用のサービスコールと非タスクコンテキスト用
のサービスコールが別々に用意されていた．非タスクコンテキストはすべてカー
ネルドメインで実行されるため，非タスクコンテキスト用のサービスコールで
rundomを参照する必要がなく，タスクコンテキストのみで有効な変数として
rundomを用意していた．

HRP3カーネルでは，同一のサービスコールを，タスクコンテキストからも非タ
スクコンテキストからも呼び出せるため，非タスクコンテキストでもrundomを
参照したいため，この方法は効率的でないと思われる．

(2-2) rundomはタスクコンテキストでも非タスクコンテキストでも有効な変数
とする．

この場合，rundomは，非タスクコンテキスト（割込みハンドラおよびCPU例外ハ
ンドラ）に入る時と，拡張サービスコールを呼び出す時に，カーネルドメイン
のビットパターン（TACP_KERNEL）に設定し，リターンする時に元の値に戻す．
また，タスク切換え時にrundomを更新する必要がある．

以上より，HRP3カーネルでは，(2-2)の方法を採用することにする．

----------------------------------------
/*
 *  実行中の保護ドメインのビットパターン
 */
ACPTN	rundom;
----------------------------------------

●svclevelの導入

タスクが拡張サービスコール実行しているか否かを判別するために，拡張サー
ビスコールのネストレベルを管理する．拡張サービスコールの中でもディスパッ
チは起こるため，拡張サービスコールのネストレベルはタスク毎に管理する必
要がある．そこで，タスク毎の拡張サービスコールのネストレベルを管理する
ために，TCBの中にuint8_t型（uint8_t型がない場合には，8ビット幅のビット
フィールドとする）のsvclevelフィールドを用意する．

----------------------------------------
typedef struct task_control_block {
	………
#ifdef UINT8_MAX
	uint8_t			svclevel;		/* 拡張サービスコールのネストレベル */
#else /* UINT8_MAX */
	BIT_FIELD_UINT	svclevel : 8;	/* 拡張サービスコールのネストレベル */
#endif /* UINT8_MAX */
	………
} TCB;
----------------------------------------

svclevelは，タスク実行開始時までに（具体的には，make_dormantで）0に初期
化し，ソフトウェア割込みによる拡張サービスコールの入口処理でインクリメ
ントし，出口処理でデクリメントする．ただし，非タスクコンテキストに対す
る拡張サービスコールのネストレベルは管理しないため，呼出し元が非タスク
コンテキストの場合には，svclevelをインクリメント／デクリメントしない．

通常のアプリケーション設計で，拡張サービスコールのネストレベルが
UINT8_MAX（＝255）を超えることは考えられないため，svclevelがオーバフロー
した場合には，システム異常とみなしてE_SYSエラーを返す．

サブルーチンコールによって拡張サービスコールの本体を呼び出した場合は，
拡張サービスコールとは見なさないこととしたため，サブルーチンコールによ
る拡張サービスコールの本体の呼出しでは，svclevelを操作しない．

----------------------------------------
void
make_dormant(TCB *p_tcb)
{
	………
	p_tcb->svclevel = 0U;
	………
}
----------------------------------------

svclevelは，あくまでも拡張サービスコールを実行しているか否かを判別する
ための変数であり，ユーザタスクが特権モードを実行しているか否かの判別に
使用することはできない．

----------------------------------------
【採用しなかった方法】

TCB中のフィールドとして，タスクが実行中の保護ドメインのビットパターンを
持つrundomを設ける方法が考えられる．タスクが拡張サービスコールに入る時
は，rundomフィールドをTACP_KERNELに設定し，リターン時に元に戻す．

この方法は，rundomを参照するのがタスクコンテキストに限られていた場合に
は有力であったが，非タスクコンテキストでも参照する必要があるHRP3カーネ
ルでは，必ずしも効率的でない．
----------------------------------------

●rundomの設定方法

rundomに，実行状態のタスクの属する保護ドメインのビットパターンを設定す
る方法は次の通り．

----------------------------------------
void
dispatch(void)
{
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_stop();					/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+	rundomをスタックに保存する
	スクラッチレジスタを除くすべてのレジスタをスタックに保存する
	……

	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
+	rundomをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
}
----------------------------------------
void
activate_context(TCB *p_tcb)
{
	……

  start_stask_r:
+	rundom = TACP_KERNEL;
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	……

  start_utask_r:
+	rundom = p_runtsk->p_dominib->domptn;
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	……
}
----------------------------------------

また，割込みとCPU例外の出入口処理においても，rundomも設定が必要である．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	………
	if (割込みがタスクコンテキストで発生) {
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_stop();				/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+		rundomをスタックに保存する
+		rundom = TACP_KERNEL;
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	………

		if (p_runtsk == NULL) {
|			タスクのスタックに保存したスクラッチレジスタ，rundom等を捨てる
			CPUロック状態にする
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない
			dispatcher_0に分岐する
		}

		………

		  ret_int_r:
			if (自タスクがユーザタスク) {
				ユーザスタックポインタをスタックから復帰する
			}
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
		}
+		rundomをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	}
	………
}
----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	………
	スクラッチレジスタをスタックに保存する
	CPU例外が発生した状況を判断するための追加情報をスタックに保存する
	この時点でのスタックポインタ±nを，CPU例外の情報を記憶している領域の
										先頭番地とする（必要なら保存する）
	if (カーネル管理外のCPU例外) {
		if (CPU例外がタスクコンテキストで発生) {
+			rundomをスタックに保存する … (*5)
+			rundom = TACP_KERNEL;
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える
		}
		システム状態（コンテキストは除く）を，CPU例外発生時の状態にする
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
		if (CPU例外がタスクコンテキストで発生) {
			スタックをタスク用のスタックに戻し，
									タスクコンテキストに切り換える
+			rundomをスタックから復帰する … (*5)
		}
		………
	}
	else {
		if (CPU例外がタスクコンテキストで発生) {
			少なくともカーネル管理の割込みを禁止した状態にする
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_stop();			/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+			rundomをスタックに保存する
+			rundom = TACP_KERNEL;
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える
		}
		………

			if (p_runtsk == NULL) {
|				タスクのスタックに保存したスクラッチレジスタ，追加
|											情報，rundom等を捨てる
				CPUロック状態にする
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない
				dispatcher_0に分岐する
			}

			………

			  ret_exc_r:
				if (自タスクがユーザタスク) {
					ユーザスタックポインタをスタックから復帰する
				}
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
+			rundomをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_start();		/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
		}
		………
}
----------------------------------------

(*5)で，カーネル管理外のCPU例外の時にもrundomを保存／変更／復帰するのは，
カーネル管理外のCPU例外からext_kerを呼び出した時に，E_OACVエラーとなら
ないようにするためである．

上のコードでは，CPU例外の出入口処理で，CPU例外がタスクコンテキストで発
生した時のみにrundomを保存／変更／復帰しているが，割込みの出入口処理と
共通化するためには，「CPU例外が発生した状況を判断するための追加情報をス
タックに保存する」前にrundomをスタックに保存する方法もある．この場合，
rundomをスタックから復帰する箇所も追加する必要があるので，注意が必要で
ある．

●オブジェクトに対するアクセス権チェックの追加

check.hに次のチェックマクロを追加し，保護の必要のあるすべてのサービスコー
ルの入口で，このマクロを用いてアクセス権のチェックを行う．

----------------------------------------
/*
 *  オブジェクトアクセス権のチェック（E_OACV）
 */
#define CHECK_ACPTN(acptn) {									\
	if (rundom != TACP_KERNEL && (rundom & (acptn)) == 0U) {	\
		ercd = E_OACV;											\
		goto error_exit;										\
	}															\
}

/*
 *  カーネルドメインからの呼出しかのチェック（E_OACV）
 */
#define CHECK_ACPTN_KERNEL() do {							\
	if (rundom != TACP_KERNEL) {							\
		ercd = E_OACV;										\
		goto error_exit;									\
	}														\
} while (false)
----------------------------------------

例えば，act_tskの場合には，次のようなコードとなる．

----------------------------------------
ER
act_tsk(ID tskid)
{
	TCB		*p_tcb;
	ER		ercd;

	LOG_ACT_TSK_ENTER(tskid);
	CHECK_UNL();								/*［NGKI1114］*/
	if (tskid == TSK_SELF && !sense_context()) {
		p_tcb = p_runtsk;						/*［NGKI1121］*/
	}
	else {
		CHECK_ID(VALID_TSKID(tskid));			/*［NGKI1115］*/
		p_tcb = get_tcb(tskid);
	}
	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn1);	/*［NGKI1117］*/

	………
----------------------------------------

●通知ハンドラの生成時におけるアクセス権チェックの追加

タイムイベントハンドラ呼出しをカーネルドメイン以外から使用した場合には，
パス2の生成スクリプトで，E_OACVエラーとする．その他のアクセス権チェッ
クについては，パス3以降のチェック段階で検出する．

●メモリ領域のアクセス保護

ユーザタスクを実行中は，メモリ管理ユニット（MMU）またはメモリプロテクショ
ンユニット（MPU）を，そのタスクが属する保護ドメインからアクセス可能なメ
モリ領域にのみアクセスできるように設定する．ここで，MMU/MPUに設定する情
報の形式は，MMU/MPUの機能や仕様に大きく依存する．将来的には，MMU/MPUを
いくつかに類型化して，その類型毎に標準的な形式を決めたいが，現時点では
ターゲット毎に形式を決定するものとする．また，その生成も，ターゲット依
存に行うこととする．

MMU/MPUに，どの保護ドメイン（ユーザドメインに限られる）に関する情報が設
定されているかを示す変数として，p_ctxdomを設ける．p_ctxdomは，MMU/MPUに
設定されている保護ドメインの保護ドメイン初期化ブロックへのポインタを設
定する．p_ctxdomは，カーネルの初期化処理でNULLに初期化する．

----------------------------------------
/*
 *  MMU/MPUに設定されている保護ドメイン
 */
DOMINIB	*p_ctxdom;
----------------------------------------
void
sta_ker(void)
{
	………
	p_ctxdom = NULL;
	………
}
----------------------------------------

ディスパッチャ本体においては，切換え後のタスクが属する保護ドメインがユー
ザドメインであり，p_ctxdomに一致していない場合に，MMU/MPUに設定されてい
るアクセス保護情報を切り換える．

----------------------------------------
void
dispatcher(void)
{
+	DOMINIB	*p_dominib;

	………

  dispatcher_0:
	p_runtsk = p_schedtsk;
	if (p_runtsk != NULL) {
		自タスク（p_runtsk）のTCBからスタックポインタを復帰する
		if (自タスクがユーザタスク) {
+			p_dominib = p_runtsk->p_dominib;
+			if (p_ctxdom != p_dominib) {
+				p_ctxdom = p_dominib;
+				p_dominibに関するアクセス保護情報をMMU/MPUに設定する
+			}
			自タスクのユーザスタック領域をアクセスできる状態とする
		}
		………
}
----------------------------------------

上のコードでは，p_dominibに関するアクセス保護情報をMMU/MPUに設定すれば，
それまでにMMU/MPUに設定されていた（切換え前の保護ドメインに関する）情報
は上書きされて設定解除されるものと想定している．この想定が成り立たない
ハードウェアでは，切換え前の保護ドメインに関する情報を，MMU/MPUから設定
解除する必要がある．

●実行状態のタスクの属する保護ドメインIDの参照

実行状態のタスクの属する保護ドメインIDを参照するget_didサービスコールは，
p_runtskのタスク初期化ブロック中の保護ドメイン初期化ブロックへのポイン
タから，所属保護ドメインIDを求める方法で実装する．

----------------------------------------
/*
 *  実行状態のタスクが属する保護ドメインIDの参照［NGKI3553］
 */
#ifdef TOPPERS_get_did

ER
get_did(ID *p_domid)
{
	ER		ercd;

	LOG_GET_DID_ENTER(p_domid);
	CHECK_UNL();								/*［NGKI2714］*/
	/* p_domidが指すメモリ領域に書き込めることのチェックが必要［NGKI2715］*/

	lock_cpu();
	*p_domid = p_runtsk->p_tinib->domid;
	ercd = E_OK;
	unlock_cpu();

  error_exit:
	LOG_GET_DID_LEAVE(ercd, *p_domid);
	return(ercd);
}

#endif /* TOPPERS_get_did */
----------------------------------------

●拡張サービスコールを呼び出した保護ドメインの参照

拡張サービスコールが，アクセス権を持った保護ドメインから呼び出されたこ
とをチェックするためには，拡張サービスコールを呼び出した保護ドメインが
参照できる必要がある．

get_didは，実行状態のタスクが属する保護ドメインを調べるためのものである．
タスク自身のコンテキストから拡張サービスコールが呼び出される場合（言い
換えると，拡張サービスコールがネストしない場合）には，get_didをこの目的
に使用できるが，拡張サービスコールから拡張サービスコールが呼び出された
場合には，この目的で使用できない．具体的には，

	タスク → 拡張サービスコール1 → 拡張サービスコール2

という呼出し関係の場合に，拡張サービスコール2の中でget_didを呼び出すと，
タスクが属する保護ドメインが返される．ここでは本来，拡張サービスコール1
の保護ドメイン，すなわちカーネルドメインを参照したい．

これを実現するために，拡張サービスコールに対して，拡張サービスコールを
呼び出した処理単位が属する保護ドメインのID番号を渡すことにする．具体的
には，拡張サービスコールの記述形式を次のようにする．cdmidは，Calling
DoMain IDを表す．

	ER_UINT extended_svc(intptr_t par1, intptr_t par2, intptr_t par3,
								intptr_t par4, intptr_t par5, ID cdmid)
	{
		拡張サービスコール本体
	}

○サービスコールの呼出し処理

●サービスコール処理関数のリネーム

アプリケーションとカーネルを1つのロードモジュールにリンクすることから，
名称の衝突を避けるために，カーネル内のサービスコール処理関数は，先頭に
_kernel_を付加した名称にリネームすることとする．例えば，task_manage.c中
のact_tsk関数は，_kernel_act_tskにリネームする．

リネームするための記述は，次に述べる理由でアプリケーションからも用いる
ため，include/svc_call.hに含める．

●関数呼出しによるサービスコール呼出し

カーネルドメインに属する処理単位から，関数呼出しによってサービスコール
を呼び出すために，TOPPERS_SVC_CALLをマクロ定義した場合には，先頭
に_kernel_を付加した名称の関数を直接呼び出すようにする．つまり，サービ
スコール関数の名称を，先頭に_kernel_を付加した名称にリネームする．また，
SVC_CALLマクロは，先頭に_kernel_を付加した名称を作るマクロとする．

このことから，先頭に_kernel_を付加した名称にリネームするための記述は，
アプリケーションからも使用することになるため，include/svc_call.hに含め，
kernel.hからインクルードする．svc_call.hには，サービスコール処理関数の
プロトタイプ宣言も含め，リネーム記述は，TOPPERS_SVC_CALLがマクロ定義さ
れている場合にのみ有効とする．svc_call.hはツール（gensvc）によって生成
する．

svc_call.hの一部分（act_tskに関連する部分）を下に示す．

----------------------------------------
extern ER _kernel_act_tsk(ID tskid) throw();

#ifdef TOPPERS_SVC_CALL
#define act_tsk _kernel_act_tsk
#ifdef TOPPERS_LABEL_ASM
#define _act_tsk __kernel_act_tsk
#endif /* TOPPERS_LABEL_ASM */
#endif /* TOPPERS_SVC_CALL */
----------------------------------------

カーネル内では先頭に_kernel_を付加した名称を使用するため，
kernel_impl.hからkernel.hをインクルードする前に，TOPPERS_SVC_CALLをマク
ロ定義する．

●ソフトウェア割込みによるサービスコール呼出し

TOPPERS_SVC_CALLをマクロ定義しない場合には，サービスコールを呼び出す関
数をターゲット依存部で実現するものとする．そのために，ターゲット依存の
ヘッダファイル（target_svc.h）を，kernel.hからインクルードする．

なお，拡張サービスコールを呼び出すためのcal_svcサービスコールは，
TOPPERS_SVC_CALLのマクロ定義の有無に関わらず，ソフトウェア割込みによっ
て呼び出すこととする．そのため，cal_svcに関するプロトタイプ宣言やリネー
ム記述はsvc_call.hには含めず，cal_svcサービスコールを呼び出す処理を，ター
ゲット依存部（target_svc.h）で実現するものとする．後述のCAL_SVC_5Mを用
いて，cal_svcサービスコールを呼び出す処理を記述すると，下のようになる．

----------------------------------------
Inline ER_UINT
cal_svc(FN fncd, intptr_t par1, intptr_t par2,
							intptr_t par3, intptr_t par4, intptr_t par5)
{
	if (fncd > 0) {
		CAL_SVC_5M(ER_UINT, fncd, intptr_t, par1, intptr_t, par2,
							intptr_t, par3, intptr_t, par4, intptr_t, par5);
	}
	else {
		return(E_RSFN);
	}
}
----------------------------------------

上記のコードでは，fncdが正であることのチェックをユーザモードで行ってい
る．これは，カーネルのサービスコールと拡張サービスコールで同一のソフト
ウェア割込みを用いることを標準としているため，fncdが負の場合にはカーネ
ルのサービスコールを呼び出してしまうためである．fncdに0または負の値を与
えても，保護が破れないようになっており，保護の観点からもこれで問題ない．

ソフトウェア割込みによってサービスコールを呼び出す場合，機能コードとパ
ラメータはレジスタに置くことを原則とする．標準のコーリングコンベンショ
ンがレジスタ渡しのプロセッサでは，パラメータを標準のコーリングコンベン
ションに従ってレジスタに置き，機能コードはその邪魔にならないレジスタに
置くのがよい．

パラメータを置くレジスタをコントロールするために，サービスコールの呼出
しルーチンはインラインアセンブラやpragma等を用いて記述する．具体的な方
法は，開発環境（コンパイラ）に依存する．

GNU開発環境においては，サービスコールの呼出しルーチンを，インラインアセ
ンブラを含むインライン関数で記述する．すべてのサービスコールに対して呼
出しルーチンを記述するのは手間がかかるため，ターゲット依存部でソフトウェ
ア割込みによってサービスコールを呼び出すためのマクロを定義した後，ツー
ル（gensvc）によって生成したarch/gcc/tool_svc.hをインクルードすることで，
各サービスコールの呼出しルーチンが定義されるようにする．

ターゲット依存部で定義すべきソフトウェア割込みによってサービスコールを
呼び出すためのマクロは次の通り．

・CAL_SVC_<n>M（<n>は0〜5までの数字）

n個の引数を持ったサービスコールをソフトウェア割込みによって呼び出すため
のマクロ．このマクロに対する引数は，返値の型，機能コード，各引数の型お
よび引数名である．

例えば，ARMにおけるCAL_SVC_1Mの定義を下に示す．

----------------------------------------
#define CAL_SVC_1M(TYPE, FNCD, TYPE1, PAR1)					\
	register intptr_t r0 asm("r0") = (intptr_t)(PAR1);		\
	register FN r5 asm("r5") = FNCD;						\
	Asm("svc %1"											\
	  : "=r"(r0)											\
	  : "I"(SVC_SERVICE_CALL),"0"(r0),"r"(r5)				\
	  : "r1","r2","r3","r12","lr","memory","cc");			\
	return((TYPE) r0);
----------------------------------------

このマクロは，機能コードをレジスタr5に，第1引数をレジスタr0に入れて，
svc #SVC_SERVICE_CALLを実行し，r0を返値とするものである．また，返値を入
れるレジスタ（r0）以外のスクラッチレジスタ（r1, r2, r3, r12, lr），メモ
リ（memory）と条件コード（cc）を，clobber指定している．これにより，ソフ
トウェア割込みの中で，スクラッチレジスタを保存する必要がなくなる．また，
サービスコールを超えた最適化が抑止される．

これを用いてact_tskを呼び出すインライン関数（tool_svc.hの一部分で，ツー
ルにより生成される）は，下のようになる．

----------------------------------------
Inline ER
act_tsk(ID tskid)
{
	CAL_SVC_1M(ER, TFN_ACT_TSK, ID, tskid);
}
----------------------------------------

----------------------------------------
【参考情報】

HRPカーネルでは，メモリをclobber指定しないCAL_SVC_<n>（<n>は0〜5までの
数字）を用意し，サービスコールで，n個の引数を持ったサービスコールの中で，
メモリを書き換える副作用を持たないものを呼び出す場合には，こちらを用い
ていた．

この方法は，次のようなコードにおいて，変数xへの代入文がサービスコール呼
出しを超えて移動されてしまう可能性があり（変数xにvolatile指定があれば移
動されないと思われる），最適化され過ぎになるという問題がある．

	wai_sem(SEM_FOR_X);
	x = 1;
	sig_sem(SEM_FOR_X);
----------------------------------------

●ソフトウェア割込みの出入口処理

ここでは，ソフトウェア割込みによるサービスコールの出入口処理の基本形に
ついて検討する．

ソフトウェア割込みの入口処理では，必要な場合，レジスタに置かれたパラメー
タをスタックに積み，機能コードに従ってサービスコール処理ルーチンを呼び
出す．カーネルコールについては，機能コードを符号反転し1を減じた値をイン
デックスとするカーネルコールの処理ルーチンの番地のテーブル（svc_table）
を用意し，そこから取り出した処理ルーチンを呼び出す．このテーブルのソー
スファイル（svc_table.c）は，ツール（gensvc）によって生成する．

ソフトウェア割込みによるサービスコールの出入口処理の処理内容は次の通り．

----------------------------------------
ER_UINT
svc_entry(パラメータリスト, FN fncd)
{
	ER_UINT		ercd;

	if (非特権モードからの呼び出し) {
		スタックを実行状態のタスクのシステムスタックに切り換える
	}
	if (fncd <= 0) {
		/*
		 *  カーネルのサービスコールの場合
		 */
		if (fncd < TMIN_FNCD) {
			ercd = E_RSFN;
			goto error_exit;
		}
		ソフトウェア割込みによりシステム状態が変化する場合には，
							ソフトウェア割込み前のシステム状態に戻す
		ercd = (*(svc_table[-fncd]))(パラメータリスト);
		ソフトウェア割込みからリターン後のシステム状態が，
							この時点でのシステム状態になるよう準備する
	}
	else {
		/*
		 *  拡張サービスコールの場合 → 次に検討
		 */
	}

  error_exit:
	if (非特権モードからの呼び出し) {
		スタックを実行状態のタスクのユーザスタックに戻す
	}
	return(ercd);
}
----------------------------------------

ここで操作対象とする必要のある「システム状態」は，全割込みロックフラグ，
CPUロックフラグ，割込み優先度マスクである．ディスパッチ禁止フラグとタス
ク例外禁止フラグは，ターゲット非依存に管理されているため，ここでの操作
対象とする必要はない．

ターゲットプロセッサによっては，スタックの切換え処理はハードウェアによっ
て行われるため，ソフトウェアで行う必要はない．

なお，ここでは，カーネルのサービスコールと拡張サービスコールを同一の入
口としているが，異なるソフトウェア割込みを用いて区別する方法もある．

●拡張サービスコールの管理と出入口処理

拡張サービスコールの呼出し処理のために，機能コードをインデックスとする
拡張サービスコール初期化ブロックのテーブル（svcinib_table）を用意し，そ
こから取り出した処理ルーチンを呼び出す．このテーブルは，コンフィギュレー
タによって生成する．

コンフィギュレータが生成する拡張サービスコール初期化ブロックのテーブル
は，次のように定義する．また，コンフィギュレータは，拡張サービスコール
の機能コードの最大値を入れた定数tmax_fncdを生成する．

----------------------------------------
/*
 *  拡張サービスコールルーチンのデータ型
 */
typedef ER_UINT	(*EXTSVC)(intptr_t par1, intptr_t par2, intptr_t par3,
								intptr_t par4, intptr_t par5, ID cdmid);
----------------------------------------
/*
 *  拡張サービスコール初期化ブロック
 */
typedef struct extended_service_call_initialization_block {
	EXTSVC		extsvc;		/* 拡張サービスコールの先頭番地 */
	SIZE		stksz;		/* 拡張サービスコールで使用するスタックサイズ */
} SVCINIB;

/*
 *  拡張サービスコールの機能コードの最大値（kernel_cfg.c）
 */
extern const FN	tmax_fncd;

/*
 *  拡張サービスコール初期化ブロックのエリア（kernel_cfg.c）
 */
extern const SVCINIB	svcinib_table[];
----------------------------------------

このテーブルを用いて拡張サービスコールへ分岐する処理（svc_entryの一部分）
は次の通り．前述の通り，タスクコンテキストから呼ばれた場合には，拡張サー
ビスコールルーチンを呼び出す前にsvclevelをインクリメントし，rundomをカー
ネルドメインのビットパターン（TACP_KERNEL）に設定する．拡張サービスコー
ルルーチンからリターンしてきたら，svclevelとrundomを元の値に戻す．

----------------------------------------
	else {
		/*
		 *  拡張サービスコールの場合
		 */
		const SVCINIB	*p_svcinib;
		ID				cdmid;

		if (fncd > tmax_fncd) {
			ercd = E_RSFN;
			goto error_exit;
		}
		p_svcinib = &svcinib_table[fncd - 1];
		if (p_svcinib->extsvc == NULL) {
			ercd = E_RSFN;
			goto error_exit;
		}

		if (非タスクコンテキストからの呼出し) {
			ソフトウェア割込みによりシステム状態が変化する場合には，
							ソフトウェア割込み前のシステム状態に戻す
			LOG_EXTSVC_ENTER(fncd, パラメータリスト, TDOM_KERNEL);
			ercd = (*(p_svcinib->extsvc))(パラメータリスト, TDOM_KERNEL);
			LOG_EXTSVC_LEAVE(fncd, ercd);
			ソフトウェア割込みからリターン後のシステム状態が，
							この時点でのシステム状態になるよう準備する
		}
		else {
			（少なくとも）カーネル管理の割込みを禁止した状態にする
			if (p_runtsk->svclevel == UINT8_MAX) {
				ercd = E_SYS;
				ソフトウェア割込みからリターン後のシステム状態が，
						ソフトウェア割込み前のシステム状態になるよう準備する
			}
			else if (システムスタック領域の残りサイズ < p_svcinib->stksz) {
				ercd = E_NOMEM;
				ソフトウェア割込みからリターン後のシステム状態が，
						ソフトウェア割込み前のシステム状態になるよう準備する
			}
			else {
				if (rundom == TACP_KERNEL) {
					cdmid = TDOM_KERNEL;
				}
				else {
					rundom = TACP_KERNEL;
					cdmid = p_runtsk->p_tinib->domid;
				}
				p_runtsk->svclevel++;
				ソフトウェア割込み前のシステム状態に戻す
				LOG_EXTSVC_ENTER(fncd, パラメータリスト, cdmid);
				ercd = (*(p_svcinib->extsvc))(パラメータリスト, cdmid);
				LOG_EXTSVC_LEAVE(fncd, ercd);
				ソフトウェア割込みからリターン後のシステム状態が，
							この時点でのシステム状態になるよう準備する
				（少なくとも）カーネル管理の割込みを禁止した状態にする
				if (--p_runtsk->svclevel == 0U) {
					rundom = p_runtsk->p_dominib->domptn;
				}
			}
		}
	}
----------------------------------------

タスクコンテキストからの拡張サービスコール呼出しの前後に，（少なくとも）
カーネル管理の割込みを禁止するのは，ディスパッチャにおいてsvclevelを参
照してrundomを値を決定するために，svclevelとrundomの更新をアトミックに
行う方が安全であるためである．

○CPU例外発生時の状態参照機能の修正

CPU例外発生時の状態参照を行うサービスコール（xsns_dpn）は，CPU例外ハン
ドラから呼び出すべきサービスコールであり，タスクコンテキストから呼び出
した場合の振舞いは，ASP3カーネルでは保証されない．HRP3カーネルでは，ユー
ザドメインから呼び出した場合に無保証になるのは避けたいため，タスクコン
テキストから呼び出した場合（ユーザドメインからの呼び出しは，必ずタスク
コンテキストである）にはtrueを返す仕様となっている．

----------------------------------------
bool_t
xsns_dpn(void *p_excinf)
{
	bool_t	state;

	LOG_XSNS_DPN_ENTER(p_excinf);
!	state = (kerflg && sense_context() && exc_sense_intmask(p_excinf)
!							&& enadsp && p_runtsk != NULL) ? false : true;
	LOG_XSNS_DPN_LEAVE(state);
	return(state);
}
----------------------------------------

○保護ドメインのメモリ管理

●用語に関する注意

以下の2つの用語は，それぞれ，粒度が異なる2つの意味で使用されるため，注
意すること．

・セクション
	リンカは，オブジェクトモジュールに含まれるセクションを結合して，実
	行形式ファイルを作成する．つまり，実行形式ファイル中のセクションは，
	リンク前のセクションを複数統合したものとなっている．そのため，リン
	ク前のセクションとリンク後のセクションは，どちらもセクションと呼ば
	れているが，粒度が異なる．

・メモリオブジェクト
	同じ性質（厳密な定義は下で述べる）を持ったメモリオブジェクトは，1つ
	に統合されてカーネルに登録される．そのため，統合前のメモリオブジェ
	クトと統合後のメモリオブジェクトは，粒度が異なる．

なお，セクション（リンカがメモリ配置を決めるための単位）とメモリオブジェ
クト（カーネルがアクセス保護の対象とする単位）は目的が異なるものであり，
どちらかがどちらかを含むという包含関係にはない．

●メモリオブジェクトの管理

メモリオブジェクトとは，カーネルがアクセス保護の対象とする一連のメモリ
領域である．

HRP3カーネルにおいては，メモリオブジェクトは以下のいずれかである．

　・ATT_SECで登録されたメモリオブジェクト
	 ※ ATT_SECで指定されたセクション（リンク前）をメモリオブジェクト
		として登録する）
　・ATT_MODで登録されたメモリオブジェクト
	 ※ ATT_MODで指定されたオブジェクトモジュールに含まれる標準のセク
	 	ション（リンク前）をそれぞれメモリオブジェクトとして登録する）
　・ATT_MEM／ATT_PMAで登録されたメモリオブジェクト
　・タスクのユーザスタック領域
　・固定長メモリプール領域（コンフィギュレータが割り付けた場合）

タスクのシステムスタック領域やデータキュー管理領域，非タスクコンテキス
ト用のスタック領域など，カーネルの用いる管理領域は，kernel_cfg.cに含ま
れていて，ATT_MODで登録した領域とみなすこととする．

固定長メモリプール領域をアプリケーションで確保する場合には，確保したメ
モリ領域はいずれかのメモリオブジェクトに含まれていなければならないため，
単独でメモリオブジェクトとはならない．

メモリオブジェクトに関する情報は，メモリに対するアクセス保護を行うため
にMMU/MPUに設定するのに加えて，サービスコールに渡されたポインタが指すメ
モリ領域に対して，サービスコールを呼び出した処理単位がアクセス権を持つ
かどうかをチェックする（これを，メモリアクセス権のチェックと呼ぶ）ため
にも使用する．MMU/MPUに設定した情報がこの目的にも使える場合には，新たな
データ構造は必要ないが，レアケースと思われる．

MMU/MPUに設定した情報がメモリアクセス権のチェックに使えない場合や，
MMU/MPUに設定する情報をシステム初期化時に動的に生成する場合には，メモ
リオブジェクトに関する情報を管理するデータ構造が必要になる．そこで，メ
モリオブジェクトに関する情報を管理する標準的なデータ構造として，メモリ
オブジェクト初期化ブロックを定義する．

●メモリオブジェクト初期化ブロック

ここでは，標準的なメモリオブジェクト初期化ブロックについて述べる．メモ
リオブジェクト初期化ブロックを用いない場合や，これと同等の情報をターゲッ
ト依存のデータ構造で管理する場合には，OMIT_STANDARD_MEMINIBをマクロ定義
し，以下で述べるのと同様の機能をターゲット依存部で実現する．

メモリオブジェクト初期化ブロックは，メモリオブジェクト毎に，その属性や
アクセス権に関する情報を管理するためのデータ構造で，コンフィギュレータ
で生成する．HRP3カーネルにおいては，いずれのメモリオブジェクトも，先頭
番地，サイズ，属性，所属ドメイン，アクセス許可ベクタが，コンフィギュレー
タおよびリンカによって静的に決定されるため，メモリオブジェクト初期化ブ
ロックは，（その名称の通り）定数データ領域に置くことができる．

メモリオブジェクト初期化ブロックは，概念的には，メモリオブジェクトの先
頭番地，属性，アクセス許可情報からなる構造体である．指定された番地がど
のメモリオブジェクトに含まれるかを効率的に検索できるように，メモリオブ
ジェクトの先頭番地の小さい順に配列に格納する．指定された番地がどのメモ
リオブジェクトに含まれるかを調べる時には，その配列をバイナリサーチする．
メモリオブジェクトの置かれていない未使用のメモリ領域にも，メモリオブジェ
クト初期化ブロックを割り当てることで，メモリオブジェクトの先頭番地のみ
を持てばよいことになる．メモリオブジェクトを先頭番地の小さい順に並べる
処理は，自動メモリ配置の場合はコンフィギュレータのパス4で，手動メモリ配
置の場合はパス2で行う．

実際のデータ構造は，バイナリサーチを効率化するために，先頭番地のみを格
納した配列と，残りの情報を格納した配列に分割する．便宜上，残りの情報を
入れる構造体をメモリオブジェクト初期化ブロックと呼ぶことにする．

HRP3カーネルは，メモリオブジェクトに対する管理操作に該当するサービスコー
ルをサポートしないため，アクセス許可ベクタに含まれるアクセス許可パター
ンの内，管理操作のアクセス許可パターン（acptn3）は必要ない．そこで，メ
モリオブジェクト初期化ブロックには，アクセス許可ベクタの代わりに，3つの
アクセス許可パターンを格納することにする．

タスクのユーザスタック領域に対する書込みアクセスと読出しアクセスは，保
護ドメイン単位でなく，タスク単位で保護されるため，アクセス許可パターン
では表現できない．そこで，タスクのユーザスタック領域として使用するメモ
リオブジェクトに対しては，通常操作1と通常操作2のアクセス許可パターンは
用いないものとする（メモリオブジェクト初期化ブロックを生成する際には，
デフォルトのアクセス許可パターンで生成する）．参照操作のアクセス許可パ
ターンは，タスクのユーザスタック領域に対しても有効である．

----------------------------------------
#ifndef OMIT_STANDARD_MEMINIB

/*
 *  メモリオブジェクト初期化ブロック
 */
typedef struct memory_initialization_block {
	ATR		accatr;			/* メモリオブジェクトアクセス属性 */
	ACPTN	acptn1;			/* 通常操作1のアクセス許可パターン */
	ACPTN	acptn2;			/* 通常操作2のアクセス許可パターン */
	ACPTN	acptn4;			/* 参照操作のアクセス許可パターン */
} MEMINIB;

/*
 *  メモリオブジェクト初期化ブロックのエントリ数（kernel_cfg.c）
 */
extern const uint_t		tnum_meminib;

/*
 *  メモリオブジェクトの先頭番地の領域（kernel_cfg.c）
 */
extern void *const		memtop_table[];

/*
 *  メモリオブジェクト初期化ブロックの領域（kernel_cfg.c）
 */
extern const MEMINIB	meminib_table[];

#endif /* OMIT_STANDARD_MEMINIB */
----------------------------------------

メモリオブジェクト初期化ブロック中のメモリオブジェクトアクセス属性
（accatrフィールド）には，メモリオブジェクトの種別とアクセス属性を示す
以下の値の論理和を設定する（この値は，ref_memが返すものである）．

まず，メモリオブジェクトの種別に対応して，以下の属性値を設定する．また，
未使用領域に対しては，TA_NOEXSを設定する．

	TA_NULL		0x0000		ATT_SECまたはATT_MODで登録されたメモリオブ
							ジェクト
	TA_ATTMEM	0x1000		ATT_MEM／ATT_PMAで登録されたメモリオブジェ
							クト
	TA_USTACK	0x2000		タスクのユーザスタック領域

この中で，HRP3カーネルの実行コードで参照しているのは，TA_USTACKと
TA_NOEXSのみである．その他の2つは，カーネルの実行コード内では区別して
扱っていない．

ATT_SECで登録されたセクションと，ATT_MODで登録されたオブジェクトモジュー
ル（に含まれる標準セクション）は，1つのメモリオブジェクトに統合される場
合があるため，ここで区別することはできない．

固定長メモリプール領域をコンフィギュレータで割り付ける場合には，固定長
メモリプール領域のみを含むセクションを作り，そのセクションをATT_SECした
扱いとするため，ATT_SECで登録したメモリオブジェクトであるものと扱う．

メモリオブジェクトのアクセス属性に対応して，以下の属性値を設定する．

	TA_NOWRITE	0x01	書込みアクセス禁止
	TA_NOREAD	0x02	読出しアクセス禁止
	TA_EXEC		0x04	実行アクセス許可
	TA_UNCACHE	0x40	キャッシュ禁止
	TA_IODEV	0x80	周辺デバイスの領域

これらの属性値は，ターゲットプロセッサに依存して拡張（または制限）して
もよい．

なお，以下のメモリオブジェクト属性は，メモリオブジェクトアクセス属性に
は含まれないため，accatrフィールドには設定しない．

	TA_MEMINI	0x08	メモリの初期化を行う
	TA_MEMZERO	0x10	メモリのクリアを行う
	TA_SDATA	0x20	ショートデータ領域に配置

メモリアクセス権のチェックを効率化するために，未使用領域（TA_NOEXS）に
対してはすべてのアクセス許可パターン（acptn1，acptn2，acptn4）を0にす
る．また，書込みアクセス禁止（TA_NOWRITE）の領域に対しては，通常操作1
（書込みアクセス）のアクセス許可パターン（acptn1）を0にする．

それに対して，読出しアクセス禁止（TA_NOREAD）の領域や実行アクセス許可
（TA_EXEC）でない領域に対しては，通常操作2（読出し・実行アクセス）のア
クセス許可パターン（acptn2）を0にしない．読出しアクセスと実行アクセスの
両方が禁止されている領域に対して0にする手もあるが，チェックを省略できず，
効率化に貢献しないため，採用していない．

メモリオブジェクト初期化ブロックのエントリ数，メモリオブジェクトの先頭
番地の領域，メモリオブジェクト初期化ブロックの領域の定義は，コンフィギュ
レータがkernel_mem.c中に生成する．この時，メモリオブジェクトの先頭番地
の領域とメモリオブジェクト初期化ブロックの領域の要素数は，コンフィギュ
レータの最後のパスでしかわからない．一方で，最後のパスとその前のパスで
生成する領域のサイズが変わるのは不都合であるため，最後のパスの前のパス
の時点でわかる最悪の場合の要素数とし，多めに確保した分はやむをえないも
のとあきらめる．

●メモリオブジェクト初期化ブロックの探索

メモリオブジェクト初期化ブロックを探索するための関数は次の通り．

----------------------------------------
/*
 *  メモリオブジェクト初期化ブロックの検索
 */
#ifndef OMIT_STANDARD_MEMINIB

int_t
search_meminib(const void *addr)
{
	int_t	left, right, i;

	left = 0;
	right = tnum_meminib - 1;
	while (left < right) {
		i = (left + right + 1) / 2;
		if ((size_t)(addr) < (size_t)(memtop_table[i])) {
			right = i - 1;
		}
		else {
			left = i;
		}
	}
	return(left);
}

#endif /* OMIT_STANDARD_MEMINIB */
----------------------------------------

※以下の文中では，ポインタの大小比較は符号なしであるものとする．

search_meminibは，

	memtop_table[i] <= addr < memtop_table[i + 1] ... (1)
	ただし，memtop_table[tnum_meminib] == ∞ とする

を満たすiを探す．このことを以下で証明する．

----------------------------------------
証明にあたり，プログラムを通じて，leftはiが取りうる範囲の最小値，right
はiが取りうる範囲の最大値であることを利用する．

[1] 最初に，プログラムを通じて，次の式が成立していることを示す．

	memtop_table[left] <= addr < memtop_table[right + 1] ... (2)
	ただし，memtop_table[tnum_meminib] == ∞ とする

まず，leftとrightの初期値は，left == 0，right == tnum_meminib - 1なの
で，ループに入る前には(2)は成立している．

次に，ループを回ることにより，(2)の関係式が維持されることを示す．ルー
プ中のif文が成立した時，すなわち「addr < memtop_table[i]」の場合， 
rightにi - 1が代入される．その結果，「i == right + 1」となるので，これ
を上の条件式に代入すると「addr < memtop_table[right + 1]」となり，(2)
の右半分が成り立つことがわかる．leftは変化しないので，左半分は明らかに
維持される．

ループ中のif文が成立しなかった時，すなわち「addr >= memtop_table[i]」
の場合，leftにiが代入される．その結果，「i == left」となるので，これを
上の条件式に代入すると「memtop_table[lett] <= addr」となり，(2)の左半
分が成り立つことがわかる．rightは変化しないので，右半分は明らかに維持
される．

以上より，プログラムを通じて常に(2)が成立していることが証明された．

[2] 次に，このプログラムが必ず終了することを示す．

「i = (left + right + 1) / 2」によって定まるiが，「left < i」かつ「i -
1 < right」を満たすことが示せれば

このことを，ループを回ることにより，iの取りうる範囲の幅が単調に狭まる，
すなわち「right - left」が単調に小さくなることを示すことによって示す．

ループ中のiの値は，

	i = (left + right + 1) / 2 ... (3)

によって定まる．まず，このiが次の2つの条件式を満たすことを示す．

	left < i ... (4)
	i - 1 < right ... (5)

ループを回るのは，「left < right」言い換えると「left + 1 <= right」の
場合である．そこで，「right >= left + 1」を(3)に代入すると，

	i >= (left + (left + 1) + 1) / 2
	  = left + 1
	  > left

より，(4)が満たされることが示せる．次に，「left <= right - 1」を(3)に
代入すると，

	i <= ((right - 1) + right + 1) / 2
	  = right
	  < right - 1

より，「i + 1 < right」が求まり，(5)が満たされることが示せる．

ループ中のiが(4)と(5)の条件式を満たすと，ループ文中のif文が成立した時
には，rightにi - 1が代入されるが，(5)よりrightが小さくなることがわかる．
if文が成立しなかった時には，leftにiが代入されるが，(4)よりleftが大きく
なることがわかる．以上より，いずれの場合にも，「right - left」は単調に
小さくなる．

[3] 最後に，ループから抜けた時点では，「left >= right」と(2)が成り立つ
ことから，leftが(1)のiの条件を満たす値になっていることがわかる．

証明終わり
----------------------------------------

ここで，search_meminibにどのような番地を渡しても正しい結果を返すために
は，メモリオブジェクト初期化ブロックの先頭のエントリの先頭番地が0でな
ければならない．

●ユーザスタック領域に含まれているかのチェック

あるメモリ領域がユーザスタック領域に含まれているかについては，メモリオ
ブジェクト初期化ブロックだけでチェックすることができない．そこで，メモ
リ領域がユーザスタック領域に含まれているかをチェックする関数
within_ustackを，次のように実装する．

----------------------------------------
/*
 *  メモリ領域がメモリオブジェクトに含まれているかのチェック
 *
 *  先頭番地がbaseでサイズがsizeのメモリ領域が，先頭番地がmobaseでサイ
 *  ズがmosizeのメモリオブジェクトに含まれている場合にtrue，そうでない
 *  場合にfalseを返す．
 */
Inline bool_t
within_memobj(const void *base, size_t size, void *mobase, size_t mosize)
{
	return((size_t)(mobase) <= (size_t)(base) && size <= mosize
			&& (size_t)((char *)(base) - (char *)(mobase)) <= mosize - size);
}

/*
 *  メモリ領域がユーザスタック領域に含まれているかのチェック
 *
 *  先頭番地がbaseでサイズがsizeのメモリ領域が，p_tcbで指定されるタスク
 *  のユーザスタック領域に含まれている場合にtrue，そうでない場合に
 *  falseを返す．
 */
#ifndef USE_TSKINICTXB

Inline bool_t
within_ustack(const void *base, size_t size, TCB *p_tcb)
{
	return(within_memobj(base, size,
					p_tcb->p_tinib->ustk, p_tcb->p_tinib->ustksz));
}

#else /* USE_TSKINICTXB */

extern bool_t	within_ustack(const void *base, size_t size, TCB *p_tcb);

#endif /* USE_TSKINICTXB */
----------------------------------------

within_memobjのreturn文中の条件判定式中の3つめの条件は，比較演算子の左
右辺の減算とも（符号なしの数として）オーバフローしないことが，その前の
2つの条件から保証される．そのため，オーバフローを気にせずに比較すること
ができる．

within_memobjでは，(base + size)がオーバフローする場合と(mobase +
mosize)が0になる場合は考慮する必要があるが，(mobase + mosize)が0を超え
てオーバフローする場合は考慮する必要がない．上記のwithin_memobjの実装は，
この場合も考慮できている．

上記のwithin_ustackの実装は，汎用のタスク初期化ブロックを用いている場合
を想定している．汎用のタスク初期化ブロックを用いていない場合は，
within_ustackをターゲット依存部で実装する必要がある．この場合にも，上の
コード中でwithin_ustackのプロトタイプ宣言を行っているのは，
target_kernel_impl.hがtask.hよりも先にインクルードされるために
target_kernel_impl.hの中ではTCBを参照することができず，このプロトタイプ
宣言が行えないためである．

●メモリアクセス権のチェック

サービスコールに渡されたポインタが指すメモリ領域に対して，サービスコー
ルを呼び出した保護ドメインがアクセス権を持つかどうかをチェックするため
に，probe_mem_writeとprobe_mem_readの2つの関数を用意する．これらの関数
は，実行中の保護ドメインがユーザドメインである時に使用するものとし，カー
ネルドメインの時には呼んではならないものとする．

これらの関数の実装では，メモリオブジェクト初期化ブロックをサーチして，
指定されたメモリ領域のアクセス許可情報を取り出し，アクセス権があるかど
うかをチェックする．

----------------------------------------
/*
 *  メモリへの書込み権のチェック
 */
#ifndef OMIT_PROBE_MEM_WRITE

bool_t
probe_mem_write(const void *base, size_t size)
{
	int_t	meminib;
	ATR		accatr;
	size_t	memsize;

	meminib = search_meminib(base);
	accatr = meminib_table[meminib].accatr;
	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
					memtop_table[meminib + 1] : 0)) - ((char *) base);

	if (accatr == TA_NOEXS) {
		return(false);
	}
	else if (size > memsize) {
		/*
		 *  指定されたメモリ領域が，複数のメモリオブジェクトにまたがっ
		 *  ている場合
		 */
		return(false);
	}
	else if ((accatr & TA_USTACK) == 0U) {
		/*
		 *  ((accatr & TA_NOWRITE) != 0U)の時は，acptn1を0にしているた
		 *  め，acptn1のチェックのみを行えばよい．
		 */
		return((rundom & meminib_table[meminib].acptn1) != 0U);
	}
	else {
		return(within_ustack(base, size, p_runtsk));
	}
}

#endif /* OMIT_PROBE_MEM_WRITE */

/*
 *  メモリからの読出し権のチェック
 */
#ifndef OMIT_PROBE_MEM_READ

bool_t
probe_mem_read(const void *base, size_t size)
{
	int_t	meminib;
	ATR		accatr;
	size_t	memsize;

	meminib = search_meminib(base);
	accatr = meminib_table[meminib].accatr;
	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
					memtop_table[meminib + 1] : 0)) - ((char *) base);

	if (accatr == TA_NOEXS) {
		return(false);
	}
	else if (size > memsize) {
		/*
		 *  指定されたメモリ領域が，複数のメモリオブジェクトにまたがっ
		 *  ている場合
		 */
		return(false);
	}
	else if ((accatr & TA_USTACK) == 0U) {
		return((accatr & TA_NOREAD) == 0U
					&& (rundom & meminib_table[meminib].acptn2) != 0U);
	}
	else {
		return(within_ustack(base, size, p_runtsk));
	}
}

#endif /* OMIT_PROBE_MEM_READ */
----------------------------------------

ここでmemsizeは，baseを含むメモリオブジェクトのサイズであり，(size >
memsize)は，baseとsizeで指定されたメモリ領域が，複数のメモリオブジェク
トにまたがっていることを判定している．この方法で判定することで，
base+sizeが0をまたぐ場合にも対応できている．

このprobe_mem_writeとprobe_mem_readの実装は，標準のメモリオブジェクト初
期化ブロックを用いている場合を想定している．標準のメモリオブジェクト初
期化ブロックを用いていない場合は，OMIT_PROBE_MEM_WRITEと
OMIT_PROBE_MEM_READをマクロ定義し，probe_mem_writeとprobe_mem_readをター
ゲット依存部で実装する必要がある．

また，プロセッサによっては，probe_mem_writeとprobe_mem_readを，プロセッ
サが持つMMU/MPU命令を使って実装した方が効率がよい場合がある．その場合に
は，ターゲット依存部でMMU/MPU命令を使ってprobe_mem_writeと
probe_mem_readを実現し，それぞれOMIT_PROBE_MEM_WRITEと
OMIT_PROBE_MEM_READをマクロ定義すればよい．

●メモリアクセス権のチェックマクロ

メモリアクセス権とアラインメントの両方をチェックするマクロとして
KERNEL_PROBE_MEM_WRITEとKERNEL_PROBE_MEM_READ，それらを用いてをエラー
チェックを行うマクロとしてCHECK_MACV_WRITEとCHECK_MACV_READを用意する．

これらの定義は以下の通り．

----------------------------------------
/*
 *  メモリアクセス権のチェックのためのマクロ
 */
#ifndef KERNEL_PROBE_MEM_WRITE
#define KERNEL_PROBE_MEM_WRITE(p_var, type) \
				(ALIGN_TYPE(p_var, type) && (rundom == TACP_KERNEL \
					|| probe_mem_write((void *)(p_var), sizeof(*(p_var)))))
#endif /* KERNEL_PROBE_MEM_WRITE */

#ifndef KERNEL_PROBE_MEM_READ
#define KERNEL_PROBE_MEM_READ(p_var, type) \
				(ALIGN_TYPE(p_var, type) && (rundom == TACP_KERNEL \
					|| probe_mem_read((void *)(p_var), sizeof(*(p_var)))))
#endif /* KERNEL_PROBE_MEM_READ */
----------------------------------------
/*
 *  メモリアクセス権のチェック（E_MACV）
 */
#define CHECK_MACV_WRITE(p_var, type) do {					\
	if (!KERNEL_PROBE_MEM_WRITE(p_var, type)) {				\
		ercd = E_MACV;										\
		goto error_exit;									\
	}														\
} while (false)

#define CHECK_MACV_READ(p_var, type) do {					\
	if (!KERNEL_PROBE_MEM_READ(p_var, type)) {				\
		ercd = E_MACV;										\
		goto error_exit;									\
	}														\
} while (false)
----------------------------------------

実行中の保護ドメインがカーネルドメインの時は，probe_mem_writeと
probe_mem_readを呼び出せないため，PROBE_MEM_WRITEとPROBE_MEM_READの中で
対処している．

また，文字列などを置いた領域のメモリアクセス権をチェックするマクロとし
てKERNEL_PROBE_BUF_WRITEとKERNEL_PROBE_BUF_READ，それらを用いてをエラー
チェックを行うマクロとしてCHECK_MACV_BUF_WRITEとCHECK_MACV_BUF_READを用
意する．

これらの定義は以下の通り．

----------------------------------------
#define KERNEL_PROBE_BUF_WRITE(base, size) \
				(rundom == TACP_KERNEL || probe_mem_write(base, size))

#define KERNEL_PROBE_BUF_READ(base, size) \
				(rundom == TACP_KERNEL || probe_mem_read(base, size))
----------------------------------------
#define CHECK_MACV_BUF_WRITE(base, size) do {				\
	if (!KERNEL_PROBE_BUF_WRITE(base, size)) {				\
		ercd = E_MACV;										\
		goto error_exit;									\
	}														\
} while (false)

#define CHECK_MACV_BUF_READ(base, size) do {				\
	if (!KERNEL_PROBE_BUF_READ(base, size)) {				\
		ercd = E_MACV;										\
		goto error_exit;									\
	}														\
} while (false)
----------------------------------------

●メモリアクセス権チェックの追加

パラメータでポインタを受け取るサービスコール内では，上記のマクロを用い
て，メモリアクセス違反エラーをチェックする．例えば，int_t型へのポインタ
変数p_xxxxxに対して書込みができるかどうかを調べるプログラムは，次のよう
になる．これにより，p_xxxxxの番地から，このポインタ変数が指す型（この場
合はint_t型）のサイズ分のメモリ領域に書き込むことができるかをチェックす
る．

----------------------------------------
	CHECK_MACV_WRITE(p_xxxxx, int_t);
----------------------------------------

HRP3カーネルでは，すべてのメモリオブジェクトの保護情報は静的に決定され
るため，上記のチェックはクリティカルセクションの外で行ってよい．

●prb_memの実装

アプリケーション（通常は拡張サービスコール）でメモリアクセス権のチェッ
クを行えるように，prb_memサービスコールを用意する．

----------------------------------------
/*
 *  メモリアクセス権のチェック（prb_memの本体）
 */
#ifndef OMIT_PROBE_MEMORY

Inline ER
probe_memory(const void *base, size_t size, TCB *p_tcb, MODE pmmode)
{
	ACPTN	domptn;
	int_t	meminib;
	ATR		accatr;
	size_t	memsize;
	ER		ercd;

	domptn = p_tcb->p_dominib->domptn;
	meminib = search_meminib(base);
	accatr = meminib_table[meminib].accatr;
	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
					memtop_table[meminib + 1] : 0)) - ((char *) base);

	if (accatr == TA_NOEXS) {
		ercd = E_NOEXS;
	}
	else if (size > memsize) {
		ercd = E_OBJ;
	}
	else if (rundom != TACP_KERNEL
				&& (rundom & meminib_table[meminib].acptn4) == 0U) {
		ercd = E_OACV;
	}
	else if (domptn == TACP_KERNEL) {
		/*
		 *  対象タスクがカーネルドメインに属する場合
		 */
		ercd = E_OK;
	}
	else if ((accatr & TA_USTACK) == 0U) {
		/*
		 *  通常のメモリオブジェクト（タスクのユーザスタック領域以外）
		 *  の場合
		 *
		 *  メモリオブジェクト属性がTA_NOWRITEの場合には，acptn1が0に
		 *  なっているので，メモリオブジェクト属性のTA_NOWRITEはチェッ
		 *  クしていない．
		 */
		if ((pmmode & TPM_WRITE) != 0U
					&& (domptn & meminib_table[meminib].acptn1) == 0U) {
			ercd = E_MACV;
		}
		else if ((pmmode & TPM_READ) != 0U && ((accatr & TA_NOREAD) != 0U
						|| (domptn & meminib_table[meminib].acptn2) == 0U)) {
			ercd = E_MACV;
		}
		else if ((pmmode & TPM_EXEC) != 0U && ((accatr & TA_EXEC) == 0U
						|| (domptn & meminib_table[meminib].acptn2) == 0U)) {
			ercd = E_MACV;
		}
		else {
			ercd = E_OK;
		}
	}
	else {
		/*
		 *  タスクのユーザスタック領域の場合
		 *
		 *  ユーザスタック領域が読出し禁止や書込み禁止になっていること
		 *  はあり得ないため，メモリオブジェクト属性のTA_NOWRITEと
		 *  TA_NOREADはチェックしていない．
		 */
		if (!within_ustack(base, size, p_tcb)) {
			ercd = E_MACV;
		}
		else if ((pmmode & TPM_EXEC) != 0U && ((accatr & TA_EXEC) == 0U)) {
			ercd = E_MACV;
		}
		else {
			ercd = E_OK;
		}
	}
	return(ercd);
}

#endif /* OMIT_PROBE_MEMORY */

/*
 *  メモリアクセス権のチェック
 *
 *  このサービスコールでは，静的なデータ構造しか参照しないため，クリティ
 *  カルセクションを作る必要がない．
 */
#ifdef TOPPERS_prb_mem

ER
prb_mem(const void *base, size_t size, ID tskid, MODE pmmode)
{
	TCB		*p_tcb;
	ER		ercd;

	LOG_PRB_MEM_ENTER(base, size, tskid, pmmode);
	CHECK_TSKCTX();								/*［NGKI2925］*/
	CHECK_PAR(size > 0U);						/*［NGKI2929］*/
	if (tskid == TSK_SELF) {
		p_tcb = p_runtsk;						/*［NGKI2939］*/
	}
	else {
		CHECK_ID(VALID_TSKID(tskid));			/*［NGKI2927］*/
		p_tcb = get_tcb(tskid);
	}
	CHECK_PAR((pmmode & ~(TPM_READ|TPM_WRITE|TPM_EXEC)) == 0U);
	CHECK_PAR(pmmode != 0U);					/*［NGKI3438］*/
	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn4);	/*［NGKI3426］*/

	ercd = probe_memory(base, size, p_tcb, pmmode);

  error_exit:
	LOG_PRB_MEM_LEAVE(ercd);
	return(ercd);
}
----------------------------------------

このprobe_memoryの実装は，標準のメモリオブジェクト初期化ブロックを用い
ている場合を想定している．標準のメモリオブジェクト初期化ブロックを用い
ていない場合は，OMIT_PROBE_MEMORYをマクロ定義し，probe_memoryをターゲッ
ト依存部で実装する必要がある．

また，プロセッサによっては，probe_memoryを，プロセッサが持つMMU/MPU命令
を使って実装した方が効率がよい場合がある．その場合には，ターゲット依存
部でMMU/MPU命令を使ってprobe_memoryを実現し，OMIT_PROBE_MEMORYをマクロ
定義すればよい．

なお，メモリオブジェクト境界を越えていることのチェックは，μITRON4.0/PX
仕様では必須とはしていないが，TOPPERS第3世代カーネル仕様では必ずチェッ
クすることとしている．ただし，プロセッサが持つMMU/MPU命令がそれに対応
できない場合には，これを緩めても良いだろう．

●メモリアクセス違反ハンドラの実装

メモリアクセス違反ハンドラは，CPU例外ハンドラの一種であると扱うこととし，
メモリアクセス違反が発生したコンテキストにおいてCPU例外が発生した場合と
同等のコンテキストで実行することを原則とする．ただし，メモリアクセス違
反ハンドラの起動方法によりそれが難しい場合には例外扱いとする．

メモリアクセス違反ハンドラは，DEF_EXCにより定義することとする．これに対
するCPU例外ハンドラ番号はターゲット依存とするが，メモリアクセス違反ハン
ドラをソフトウェアでエミュレートする場合で，メモリアクセス違反ハンドラ
の種類が1つの場合のために，CPU例外ハンドラ番号をマクロ定義するためのシ
ンボルを次のように決める．

	EXCNO_MEM_ACV		メモリアクセス違反ハンドラ

○メモリオブジェクトの登録と配置

●登録すべきメモリオブジェクト

一般的なターゲットシステムにおいては，カーネルに登録すべきメモリオブジェ
クトには次のものがある（括弧内のセクション名は，GNU開発環境における標準
的な名称である）．

(a) ATT_SECで登録されたメモリオブジェクト
(b) ATT_MODで登録されたメモリオブジェクト
(b-1) コードセクション（.text）
(b-2) 定数データセクション（.rodata）
(b-3) 初期化データセクション（.data）
(b-4) クリアデータセクション（.bss）
(c) ATT_MEM／ATT_PMAで登録されたメモリオブジェクト
(d) タスクのユーザスタック領域
(d-1) コンフィギュレータが割り付けた場合
(d-2) アプリケーションで指定した場合
(e) 固定長メモリプール領域（コンフィギュレータが割り付けた場合）

ターゲットによっては，(b-1)と(b-2)が分離できない場合がある．

システムの起動時間を短縮するためには，初期化／クリアを行わないデータセ
クションがあると都合がよい．そこで，コンパイラは標準では出力しないが，
初期化／クリアを行わないデータセクションとして，以下を標準のセクション
と扱う（統合仕様書では，ターゲット定義で標準のセクションを増やしてよい
ことになっている［NGKI0113］）．

(b-5) 非初期化データセクション（.noinit）

さらに，ショートデータ領域を持つターゲットでは，次の4つが標準のセクショ
ンに追加される．

(b-6) ショート定数データセクション（.srodata）
(b-7) ショート初期化データセクション（.sdata）
(b-8) ショートクリアデータセクション（.sbss）
(b-9) ショート非初期化データセクション（.snoinit）

これらのメモリオブジェクトの中で，(a)，(b-1)〜(b-9)，(d-1)，(e)は，コ
ンフィギュレータがメモリに配置する．正確には，コンフィギュレータがリン
カスクリプトを生成し，リンカがメモリへの配置を決定する．他のメモリオブ
ジェクト（(c)，(d-2)）は，どの番地に置くかをアプリケーションが指定する．

さらにターゲットによっては，ショートデータ領域よりもさらに小さいデータ
領域（例えば，タイニーデータ領域）を持つ場合がある．これらへの対応は，
今後の課題である（ターゲット依存部だけで対応できればよいが，ターゲット
非依存部の修正が必要となる可能性が高い）．

●標準のメモリオブジェクト属性

標準のセクションに対してデフォルトで設定するメモリオブジェクト属性を，
標準のメモリオブジェクト属性と呼ぶ．標準のメモリオブジェクト属性は，標
準のセクション毎にターゲット依存部で定義する．標準のメモリオブジェクト
属性と，ターゲット依存部で変更しない場合のデフォルトの定義は，以下の通
りである．

TA_TEXTSEC：コードセクションの標準的なメモリオブジェクト属性
	デフォルトの定義：TA_NOWRITE|TA_EXEC
	
TA_RODATASEC：定数データセクションの標準的なメモリオブジェクト属性
	デフォルトの定義：TA_NOWRITE

TA_DATASEC：初期化データセクションの標準的なメモリオブジェクト属性
	デフォルトの定義：TA_MEMINI

TA_BSSSEC：クリアデータセクションの標準的なメモリオブジェクト属性
	デフォルトの定義：TA_MEMZERO

TA_NOINITSEC：非初期化データセクションの標準的なメモリオブジェクト属性
	デフォルトの定義：TA_NULL

ショートデータセクションに対しては，上記に加えて，TA_SDATAも指定する．

標準のメモリオブジェクト属性と通常操作1および通常操作2のアクセス許可パ
ターンを持つ○○セクションを，標準○○セクションと呼ぶ．例えば，標準コー
ドセクションとは，標準のメモリオブジェクト属性と通常操作1および通常操
作2のアクセス許可パターンを持つコードセクションのことをいう．また，標
準のメモリオブジェクト属性と通常操作1および通常操作2のアクセス許可パター
ンを持つ○○領域を，標準○○領域と呼ぶ．

●配置先メモリリージョン，保護ドメイン，属性，アクセス許可ベクタ

カーネルに登録するメモリオブジェクトに対しては，配置先のメモリリージョ
ン（リンカが配置する場合のみ），属する保護ドメイン（または無所属），メ
モリオブジェクト属性，アクセス許可ベクタを定める必要がある．ただし，管
理操作のアクセス許可パターン（acptn3）は，HRP3カーネルでは使用しない．
また，メモリオブジェクトがTA_NOWRITE属性の場合には，通常操作1のアクセス
許可パターン（acptn1）も使用しない．

以下，登録すべきメモリオブジェクトの種類毎に，配置先メモリリージョン，
保護ドメイン，属性，アクセス許可ベクタがどのように定まるかを整理する．

(a) ATT_SECで登録されるメモリオブジェクト

配置先のメモリリージョン，属する保護ドメイン，メモリオブジェクト属性，
アクセス許可ベクタのすべてが静的API（ATT_SEC）で指定される（属する保護
ドメインは，静的APIがどの保護ドメインの囲みの中に記述されるかで指定さ
れる．以下同じ）．

(b) ATT_MODで登録されるメモリオブジェクト

属する保護ドメインとアクセス許可ベクタが静的API（ATT_MOD）で指定される．
配置先のメモリリージョンとメモリオブジェクト属性は，標準のセクション毎
にターゲット依存部で定める．ターゲット依存部で設定する配置先のメモリリー
ジョンとメモリオブジェクト属性は，一般的には次の表のようになる．

------------------------------------------------------------------------------
標準のセクションの種類		メモリリージョン			メモリオブジェクト属性
------------------------------------------------------------------------------
コードセクション			標準ROMリージョン			TA_TEXTSEC
定数データセクション		標準ROMリージョン			TA_RODATASEC
初期化データセクション		標準RAMリージョン			TA_DATASEC
クリアデータセクション		標準RAMリージョン			TA_BSSSEC
非初期化データセクション	標準RAMリージョン			TA_NOINITSEC
定数ショートデータセクシ...	標準ショートROMリージョン	TA_RODATASEC|TA_SDATA
初期化ショートデータセク...	標準ショートRAMリージョン	TA_DATASEC|TA_SDATA
クリアショートデータセク...	標準ショートRAMリージョン	TA_BSSSEC|TA_SDATA
非初期化ショートデータセ...	標準ショートRAMリージョン	TA_NOIITSEC|TA_SDATA
------------------------------------------------------------------------------

ショートデータをアクセスするためのグローバルポインタが1つしかないター
ゲットでは，ショートデータセクションが複数のメモリリージョンに別れて配
置されると，グローバルポインタ相対でアクセスできなくなる可能性があり，
不都合である．

このようなターゲットでは，DEF_SRGにより，標準ショートROMリージョンを標
準ショートRAMリージョンと一致させる．これにより，定数ショートデータセ
クションを，RAMに配置することになる．この状況で，定数ショートデータセ
クションの値をROMから初期化するために，以下の仕様とした．

	TA_NOWRITE属性のメモリオブジェクトが，TA_NOWRITE属性でないメモリリー
	ジョンに登録された場合，そのメモリオブジェクトは，TA_MEMINI属性を
	設定した場合と同様に扱われる［NGKI3985］．

なお，ショートデータセクションを，想定しないメモリリージョンに配置した
場合，グローバルポインタ相対でアクセスできなくなる可能性がある．アクセ
スできない場合には，リンカがエラーを報告すると思われるため，コンフィギュ
レータではエラーチェックを行わず，ユーザの責任とする．

(c) ATT_MEM／ATT_PMAで登録されるメモリオブジェクト

配置先のメモリリージョンは意味がないため定義されず，属する保護ドメイン，
メモリオブジェクト属性，アクセス許可ベクタは，静的API（ATT_MEM／
ATT_PMA）で指定される．

(d-1) コンフィギュレータが割り付けるタスクのユーザスタック領域

配置先のメモリリージョンをタスクが属する保護ドメインの標準RAMリージョ
ン，属する保護ドメインをタスクと同じ，メモリオブジェクト属性をターゲッ
ト定義の値（TARGET_MEMATR_USTACK，標準的にはTA_NOINITSECと同じ）に設定
する．通常操作1と通常操作2のアクセス許可パターンは意味を持たないが
［NGKI0439］，レッドゾーン方式のスタック保護を行う場合を考えて，いずれ
も，タスクが属する保護ドメインのみに許可する値に設定する．参照操作に対
するアクセス許可パターンは，タスクと同じ値に設定する［NGKI0609］．

(d-2) アプリケーションで指定するタスクのユーザスタック領域

配置先のメモリリージョンは意味がないため定義されない以外は，コンフィギュ
レータが割り付けるタスクのユーザスタック領域(d-1)と同じである．

(e) コンフィギュレータが割り付ける固定長メモリプール領域

配置先のメモリリージョンを固定長メモリプールが属する保護ドメインの標準
のRAMリージョン，属する保護ドメインを固定長メモリプールと同じ，メモリ
オブジェクト属性をターゲット定義の値（TARGET_MEMATR_MPFAREA．標準的に
はTA_NOINITSECと同じ），アクセス許可ベクタを固定長メモリプールと同じに
設定する．

●メモリオブジェクトの統合

(a)，(b-1)〜(b-9)，(e)のメモリオブジェクトで，以下の条件を満たすものは，
1つのメモリオブジェクトに統合することができる［NGKI2829］［NGKI2855］
［NGKI2242］．

・配置先のメモリリージョンが同じ
・メモリオブジェクトアクセス属性が同じ
・アクセス許可ベクタが同じ（acptn1，acptn2，acptn4がすべて同じ）

この3つの条件を満たすメモリオブジェクトで，属する保護ドメインと
TA_SDATA属性の有無も一致しているものは連続して配置し，1つのメモリオブ
ジェクトに統合する．属する保護ドメインが異なるものや，TA_SDATA属性の有
無が異なるものは，連続して配置された場合にのみ1つのメモリオブジェクト
に統合する．

さらに，上の条件の中で，参照操作のアクセス許可パターン（acptn4）が同じ
という条件のみを満たさないメモリオブジェクト（言い換えると，acptn4が異
なることを除いては上の条件を満たすメモリオブジェクト）は，MMU/MPUに設
定するメモリ保護情報の観点では違いがない．そこで，これらのメモリオブジェ
クトは，属する保護ドメインとTA_SDATA属性の有無も一致しているものは連続
して配置し，メモリ保護の際には1つにまとめて扱う．属する保護ドメインが
異なるものや，TA_SDATA属性の有無が異なるものは，連続して配置された場合
にのみ1つにまとめて扱う．この単位を，メモリ保護単位と呼ぶ．

逆に，1つの統合後メモリオブジェクトの中に，TA_MEMINI属性の有無と
TA_MEMZERO属性の有無が異なる統合前メモリオブジェクトが混在することにな
るが，これらは，メモリ領域の初期化のためには別々に扱わなければならない．
そこで，1つに統合される統合前メモリオブジェクトの中で，TA_MEMINI属性の
もの，TA_MEMZERO属性のもの，どちらでもないものは，それぞれ連続して配置
し，1つのセクションにリンクする．

以上より，1つのメモリ保護単位には一般に複数の統合後メモリオブジェクト
が含まれ，1つの統合後メモリオブジェクトには一般に複数の（リンク後）セ
クションが含まれ，1つの（リンク後）セクションには一般に複数の統合前メ
モリオブジェクトが含まれるという関係になる．

----------------------------------------
【採用しなかった方法】

HRP2カーネルおよびHRP3カーネルの3.B.0まででは，メモリオブジェクトアク
セス属性だけではなく，メモリオブジェクト属性全体が一致するものを，1つ
のメモリオブジェクトに統合できることとしていた（外部仕様における統合可
能な条件が異なっていた）．

具体的には，メモリオブジェクトの配置方法を，参照操作のアクセス許可パター
ン（acptn4）が異なることを除いて条件を満たすものを連続して配置し，その
後，メモリオブジェクト属性の中のTA_MEMINI属性とTA_MEMZERO属性の有無を
除いて条件を満たすものを連続して配置することとしていた．そのため，1つ
のメモリ保護単位には一般に複数の（リンク後）セクションが含まれ，1つの
（リンク後）セクションには一般に複数の統合後メモリオブジェクトが含まれ，
1つの統合後メモリオブジェクトには一般に複数の統合前メモリオブジェクト
が含まれるという関係になっていた．

この方法と比較して，採用した方法には次の利点がある．TA_MEMINI属性と
TA_MEMZERO属性の有無はメモリの保護属性に影響しないため，TA_MEMINI属性
とTA_MEMZERO属性の有無によらずメモリオブジェクトを統合し，統合後メモリ
オブジェクト数を減らすことができる．

逆に，初期化／クリアが必要なデータセクションが細切れになるという欠点が
ある．
----------------------------------------

ATT_MEM／ATT_PMAで登録されたメモリオブジェクト（前記の(c)）は，メモリ
オブジェクトをまとめる処理を行わない．また，他のメモリオブジェクトとま
とめて1つのメモリ保護単位にすることもなく，統合前メモリオブジェクト毎
にメモリ保護単位とする．

●タスクのユーザスタック領域の扱い

タスクのユーザスタック領域（前記の(d-1)と(d-2)）は，個々のユーザスタッ
ク領域をメモリオブジェクトとして登録し，メモリオブジェクトをまとめる処
理を行わない．また，他のメモリオブジェクトとまとめて1つのメモリ保護単
位にすることもなく，統合前メモリオブジェクト毎にメモリ保護単位とする．
つまり，次に説明する固定長メモリプール領域の場合と異なり，ATT_SECした
のと同様には扱わない．

GNU開発環境の場合，リンク前セクションの名称と，リンク後セクションの名
称を一致させ，.ustack_<タスク名>とする．例えば，タスク名がTASK1のタス
クのユーザスタック領域は，リンク前後とも，.ustack_TASK1という名称のセ
クション内に配置される．

●固定長メモリプール領域の扱い

固定長メモリプール領域をコンフィギュレータで割り付ける場合（前記の(e)）
には，固定長メモリプール領域のみを含む（リンク前）セクションを作成し，
そのセクションをATT_SECしたのと同様に扱う．

そのため，条件を満たせば，他のメモリオブジェクトと同じ（リンク後）セク
ションにリンクし，1つのメモリオブジェクトに統合する．

●用語の整理

以下では，統合仕様書に定義されている次の用語を用いる．

・専有リードオンリー領域［NGKI0418］（専有RO領域）
	メモリオブジェクトが属する保護ドメインのみに，読出しアクセス（実行
	アクセスを含む）のみが許可されている領域

・専有リードライト領域［NGKI0419］（専有RW領域）
	メモリオブジェクトが属する保護ドメインのみに，書込みアクセスと読出
	しアクセス（実行アクセスを含む）が許可されている領域

・共有リードオンリー領域［NGKI0420］（共有RO領域）
	すべての保護ドメインに，読出しアクセス（実行アクセスを含む）のみが
	許可されている領域

・共有リードライト領域［NGKI0421］（共有RW領域）
	すべての保護ドメインに，書込みアクセスと読出しアクセス（実行アクセ
	を含む）が許可されている領域

・共有リード専有ライト領域［NGKI0422］（SRPW領域）
	メモリオブジェクトが属する保護ドメインに，書込みアクセスと読出しア
	クセス（実行アクセスを含む）が許可されており，他の保護ドメインには，
	読出しアクセス（実行アクセスを含む）のみが許可されている領域

	なお，無所属の共有リード専有ライト領域はないものとする（無所属の共
	有リードライト領域と同じ扱いとなるため）．

共有リードオンリー領域と共有リードライト領域は，無所属であることが一般
的であるが，保護ドメインに属している場合もある．どの保護ドメインに属し
ていても，メモリ保護単位としては1つにまとめることができる．

カーネルドメインでMMU/MPUが無効になるターゲットなどでは，カーネルドメイ
ンの専有リードオンリー領域と専有リードライト領域は同じ扱いとなる．また，
カーネルドメインの共有リード専有ライト領域は，共有リードオンリー領域と
同じ扱いとなる．

さらに，次の用語を用いる．

・コード領域
	リードオンリー領域の中で，メモリオブジェクト属性にTA_EXECが設定され
	ている領域．専有／共有リードオンリー領域の中で，メモリオブジェクト
	属性にTA_EXECが設定されている領域を，専有／共有コード領域と呼ぶ．

・定数データ領域
	リードオンリー領域の中で，メモリオブジェクト属性にTA_EXECが設定され
	ていない領域．専有／共有リードオンリー領域の中で，メモリオブジェク
	ト属性にTA_EXECが設定されていない領域を，専有／共有定数データ領域と
	呼ぶ．

・保護領域
	MPUが保護対象とするメモリ領域．

●メモリオブジェクトの配置順序

ここでは，コンフィギュレータが，メモリオブジェクトをメモリに配置する順
序について検討する．すなわち，前記の(a)，(b-1)〜(b-9)，(d-1)，(e)のメモ
リオブジェクトがここでの検討対象である．

ここまでに述べた通り，統合前メモリオブジェクトはセクションに，セクショ
ンは統合後メモリオブジェクトに，統合後メモリオブジェクトはメモリ保護単
位にまとめて配置する（つまり，連続して配置する）．そこで，まずはメモリ
保護単位の配置順序を検討し，次にメモリ保護単位内でのメモリオブジェクト
およびセクションの配置順序を検討する．

メモリ保護単位の配置順序は，ROMリージョン（TA_NOWRITE属性のメモリリー
ジョン）とRAMリージョン（TA_NOWRITE属性でないメモリリージョン）に対し
て個別に検討する．

1つのメモリリージョンに，ROMリージョンに配置すべきメモリ保護単位と，
RAMリージョンに配置すべきメモリ保護単位が混在する場合は，ROMリージョン
に配置すべきメモリ保護単位を最初に配置し，その後に，RAMリージョンに配
置すべきメモリ保護単位を配置する．標準ROMリージョンと標準RAMリージョン
を同じに設定した場合には，この配置規則が適用されることになる．

●ROMリージョンにおけるメモリ保護単位の配置順序

ROMリージョンに配置すべきメモリ保護単位（TA_NOWRITE属性のメモリオブジェ
クトをまとめたメモリ保護単位）については，次のことを考慮して配置する．

・同一のセクション（.text，.rodata，.srodata）の中で，無所属の標準共有
　セクションを最後に配置する．(*A)

　＊この制約は，現時点では必要なくなっている．

　＊この制約には，過去のバージョンとの互換性以上の理由はない．過去のバー
	ジョンでは，GNU開発環境で，ATT_MODで指定されなかった標準ライブラリ
	（少なくともlibgcc.a）を，ワイルドカードを使って無所属の標準共有セ
	クション（標準共有コードセクション，標準共有定数データセクション，
	標準共有ショート定数データセクション）にリンクしていたため，この制
	約が必要であった．

・言語依存（具体的にはC++用）のセクションを出力するためには，無所属の
　標準共有定数データ領域を最後に配置するのが都合がよい．(*B)

・ターゲットによっては，カーネルの起動番地が先頭に置かれている必要があ
　る可能性を考え，カーネルドメインの標準専有コード領域を先頭に配置する．
　(*C)

・標準共有定数データ領域は，属する保護ドメインによらず連続して配置し，
　1つのメモリ保護単位にまとめる．標準共有定数データ領域を特別扱いする
　のは，標準共有リード専有ライトにする意図でATT_MODしたモジュールに定
　数データセクションが含まれていた場合に，このような領域が作られるため
　である．(*D)

また，ショート定数データ領域をROMリージョンに置く場合（ショート定数デー
タ領域の配置先が標準ショートRAMリージョンでない場合）には，次のことも
考慮する必要がある．

・すべてのショートデータ領域を連続して配置する．さらに，MPUの保護領域数
　を最小限にするために，標準共有定数データ領域は，ショートデータ領域と
　一般の領域を連続して配置し，1つのメモリ保護単位にまとめる．(*E)

これら以外にはメモリ保護単位を配置する上での考慮事項はなく，これらを満
たす範囲でどのような順序で配置しても差し支えないが，なるべく自然な順序
にすることを考慮し，次のような順序で配置することにする．

	カーネルドメインの標準専有コード領域 (*C)
	カーネルドメインのTA_NOWRITE属性のその他の領域
	各ユーザドメインのTA_NOWRITE属性のその他の領域
	無所属のTA_NOWRITE属性のその他の領域
	無所属の標準共有コード領域 (*A)
	カーネルドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）(#)
	各ユーザドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）(#)
	無所属のROMに配置すべきその他の領域（ショートデータ領域）(#)
|	カーネルドメインの標準共有定数データ領域（ショートデータ領域）(#)
|	各ユーザドメインの標準共有定数データ領域（ショートデータ領域）(#)
|	無所属の標準共有定数データ領域（ショートデータ領域）(#)(*A)
|	カーネルドメインの標準共有定数データ領域
|	各ユーザドメインの標準共有定数データ領域
|	無所属の標準共有定数データ領域 (*A)(*B)

	※ "|"で示した領域は，1つのメモリ保護単位にまとめることを示す．(*D)(*E)
	※ (#)で示した領域は，ショート定数データ領域をROMリージョンに置く場
	   合のみ存在する．

各ユーザドメインに対する領域は，ユーザドメイン1の領域から順に配置する．
例えば「各ユーザドメインのROMに配置すべきその他の領域」は，以下のように
展開する．

	ユーザドメイン1のROMに配置すべきその他の領域
	ユーザドメイン2のROMに配置すべきその他の領域
	……
	ユーザドメインnのROMに配置すべきその他の領域

それぞれ領域の中では，TA_EXEC属性があるセクション（textセクションなど）
を最初に配置する．

ショートデータ領域を標準RAMリージョンに配置する場合には，上記の配置順
序は適用しない．ショートデータ領域のRAMリージョン内での配置順序につい
ては，次の節で述べる．

----------------------------------------
【採用しなかった方法】

HRP2カーネルおよびHRP3カーネルの3.B.0まででは，以下の配置ルールを用いて
いたが，配置順序をそこまで決める必要がないことから，現在のバージョンで
は採用していない．

カーネルドメインのROMに配置すべき領域の中では，標準専有コード領域を先
頭に配置する必要があることから，メモリオブジェクト属性と通常操作2のア
クセス許可パターン（acptn2）のいずれも標準的な領域を最初に配置し，次に
メモリオブジェクト属性が標準的でアクセス許可パターンが標準的でない領域
を，最後にいずれも標準的でない領域を配置する．また，それぞれの領域の中
では，TA_EXEC属性があるメモリ保護単位（コード領域）を先に配置し，
TA_EXEC属性がないメモリ保護単位（定数データ領域）を後に配置する．

各ユーザドメインのROMに配置すべき領域の中も，カーネルドメインと同様の順
序で配置する．

無所属のROMに配置すべき領域の中は，無所属の標準データ領域を最後に配置
する必要があることから，カーネルドメインとは逆の順序で配置する．ただし，
それぞれの領域の中で，TA_EXEC属性があるメモリ保護単位を先，TA_EXEC属性
がないメモリ保護単位を後という順序は逆にしない．
----------------------------------------

●RAMリージョンにおけるメモリ保護単位の配置順序

RAMリージョンに配置すべきメモリ保護単位（TA_NOWRITE属性でないメモリオ
ブジェクトをまとめたメモリ保護単位）については，次のことを考慮して配置
する．

・同一の（リンク前）セクションの中で，無所属の標準共有セクションを最後
　に配置する（標準ライブラリが静的データを持つのは，メモリ保護の観点か
　らは問題があるが，ユーザの責任である）．(*F)

　＊この制約には，過去のバージョンとの互換性以上の理由はない．過去のバー
	ジョンでは，GNU開発環境で，ATT_MODで指定されなかった標準ライブラリ
	（少なくともlibgcc.a）をワイルドカードを使って無所属の標準共有セク
	ション（標準共有初期化データセクション，標準共有クリアデータセクショ
	ン，標準共有非初期化データセクション，それぞれのショートセクション）
	にリンクしていたため，この制約が必要であった．

・ユーザスタックのオーバフローが確実に検出できることが望ましい．すなわ
　ち，ユーザタスクのスタック領域をスタックの進行方向にはみ出した番地に
　は，そのタスクがアクセスできないメモリ領域が配置されていること．さら
　に，スタックの進行方向の逆方向にはみ出した番地についても同様になって
　いることが望ましい．(*G)

・MPUの保護領域数を最小限にするために，すべての保護ドメインの標準共有
　リード専有ライト領域を，連続して配置する（標準共有定数データ領域が途
　中に入るのは差し支えない）．(*H)

・すべてのショートデータ領域を連続して配置する．さらに，MPUの保護領域数
　を最小限にするために，無所属の標準共有リードライト領域は，ショートデー
　タ領域と一般の領域を連続して配置する．(*I)

・標準ROMリージョンの配置順序と，なるべく同じ方針で配置するのが望ましい．

また，ショート定数データ領域をRAMリージョンに置く場合（ショート定数デー
タ領域の配置先が標準ショートRAMリージョンである場合）には，次のことも
考慮する必要がある．

・標準共有定数データ領域（ショートデータ領域）は，属する保護ドメインに
　よらず，1つのメモリ保護単位にまとめる．標準共有定数データ領域（ショー
　トデータ領域）を特別扱いする理由は，(*D)と同様である．(*J)

これらを踏まえて，次のような順序で配置することにする．

	カーネルドメインのTA_NOWRITE属性でないその他の領域
	カーネルドメインの専有リードライト領域 (*G) … (*1)
	各ユーザドメインに属する各タスクのユーザスタック領域 (*G)
	各ユーザドメインのTA_NOWRITE属性でないその他の領域
	無所属のTA_NOWRITE属性でないその他の領域
+	カーネルドメインの標準共有リード専有ライト領域
+	各ユーザドメインの標準共有リード専有ライト領域
+	カーネルドメインの標準共有リード専有ライト領域（ショートデータ領域）
+	各ユーザドメインの標準共有リード専有ライト領域（ショートデータ領域）
	カーネルドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）(#)
	各ユーザドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）(#)
	無所属のTA_NOWRITE属性のその他の領域（ショートデータ領域）(#)
!	カーネルドメインの標準共有定数データ領域（ショートデータ領域）(#)
!	各ユーザドメインの標準共有定数データ領域（ショートデータ領域）(#)
!	無所属の標準共有定数データ領域（ショートデータ領域）(#)(*A)
	カーネルドメインのTA_NOWRITE属性でないその他の領域（ショートデータ領域）
	各ユーザドメインのTA_NOWRITE属性でないその他の領域（ショートデータ領域）
	無所属のTA_NOWRITE属性でないその他の領域（ショートデータ領域）
|	無所属の標準共有リードライト領域（ショートデータ領域）(*F)
|	無所属の標準共有リードライト領域 (*F)

	※ "+"で示した領域は，すべての保護ドメインからリードアクセスできる
	   ように設定する．ここに含まれる共有リード専有ライト領域について
	   は，それが属する保護ドメインからはライトアクセスもできるように
	   設定する．(*H)
	※ "!"で示した領域は，1つのメモリ保護単位にまとめることを示す．(*J)
	※ "|"で示した領域は，1つのメモリ保護単位にまとめることを示す．(*I)
	※ (#)で示した領域は，ショート定数データ領域をRAMリージョンに置く場
	   合のみ存在する．
	※ (*1) カーネルドメインのTA_NOWRITE属性でない領域の中で，専有リー
	   ドライト領域を最後に配置するのは，ユーザスタックのオーバフロー
	   を確実に検出するためである．(*G)

ここで，ユーザドメインが1つしかない場合には，ユーザドメイン1に属するタ
スクのユーザスタックの直後に，ユーザドメイン1の専有リードライト領域が配
置されてしまうが，スタックの進行方向の逆方向にはみ出した側なので，許容
することにする．また，ユーザドメインが複数ある場合でも，ユーザドメイン
の専有リードライト領域が空の場合には，後続のユーザドメインで同様のこと
が起こる可能性がある．

標準共有定数データ領域（ショートデータ領域）と標準共有リード専有ライト
領域（ショートデータ領域）を連続して配置できると，その全体をリードアク
セスできるように設定することで，MPUの1つの保護領域で保護できる場合があ
る．上のメモリ配置順序では，これが連続して配置されることは保証されない
が，それらの間に入る領域が空の場合には，連続して配置される場合もある．
連続配置された場合には，MPUの保護領域を節約することができる．

なお，MMUを持ったターゲットシステムで，レッドゾーン方式のスタック保護を
行う場合には，同じユーザドメインに属するタスクのユーザスタック領域が隣
接しないように配置する．必要な場合（全体の半分を越えるユーザタスクが1つ
のユーザドメインに属する場合）には，ダミーのスタック領域を追加してスタッ
ク保護を行う．この配置アルゴリズムについては，後述する．

----------------------------------------
【採用しなかった方法】

HRP2カーネルおよびHRP3カーネルの3.B.0まででは，以下の配置ルールを用いて
いたが，配置順序をそこまで決める必要がないことから，現在のバージョンで
は採用していない．

各ユーザドメインのRAMに配置すべき領域の中では，ROMへの配置順序となるべ
く同じ方針とするために，メモリオブジェクト属性と通常操作1および2のアク
セス許可パターン（acptn1およびacptn2）のいずれも標準的な領域を最初に配
置し，次にメモリオブジェクト属性が標準的でアクセス許可パターンが標準的
でない領域を，最後にいずれも標準的でないメモリ保護単位を配置する．

カーネルドメインと無所属のRAMに配置すべき領域の中は，それぞれ，標準専
有リードライト領域と共有リードライト領域を最後に配置する必要があること
から，ユーザドメインとは逆の順序で配置する．
----------------------------------------

●メモリ保護単位内での配置順序

メモリ保護単位の中では，acptn4が標準のメモリオブジェクトを最初に配置す
る．ただし，無所属のメモリ保護単位の中では，acptn4が標準のメモリオブジェ
クトを最後に配置する．

メモリオブジェクトの中では，TA_MEMINI属性があるセクション（dataセクショ
ンなど）を最初に配置し，次にTA_MEMZERO属性があるセクション（bssセクショ
ンなど）を，最後にTA_MEMINI属性・TA_MEMZERO属性ともないセクション（非
初期化データセクションなど）を配置する．

●メモリオブジェクトの配置順序の実装

前述の配置順序を実現するために，配置順にソートするために用いる「配置タ
イプ」を導入する．配置タイプは，メモリオブジェクトが属する保護ドメイン
等により，以下の通りに定める．

----------------------------------------
【配置タイプ1】
	カーネルドメインの標準専有コード領域

【配置タイプ2】
	カーネルドメインのTA_NOWRITE属性のその他の領域
	各ユーザドメインのTA_NOWRITE属性のその他の領域
	無所属のTA_NOWRITE属性のその他の領域

【配置タイプ3】
	無所属の標準共有コード領域

【配置タイプ4】
	＊ショート定数データ領域をROMリージョンに置く場合＊
	カーネルドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）
	各ユーザドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）
	無所属のROMに配置すべきその他の領域（ショートデータ領域）

【配置タイプ5】
	＊ショート定数データ領域をROMリージョンに置く場合＊
	カーネルドメインの標準共有定数データ領域（ショートデータ領域）
	各ユーザドメインの標準共有定数データ領域（ショートデータ領域）
	無所属の標準共有定数データ領域（ショートデータ領域）

【配置タイプ6】
	カーネルドメインの標準共有定数データ領域
	各ユーザドメインの標準共有定数データ領域
	無所属の標準共有定数データ領域

【配置タイプ7】
	カーネルドメインのTA_NOWRITE属性でないその他の領域

【配置タイプ8】
	カーネルドメインの専有リードライト領域

【配置タイプ9】
	各ユーザドメインに属する各タスクのユーザスタック領域

【配置タイプ10】
	各ユーザドメインのTA_NOWRITE属性でないその他の領域
	無所属のTA_NOWRITE属性でないその他の領域

【配置タイプ11】
	カーネルドメインの標準共有リード専有ライト領域
	各ユーザドメインの標準共有リード専有ライト領域

【配置タイプ12】
	カーネルドメインの標準共有リード専有ライト領域（ショートデータ領域）
	各ユーザドメインの標準共有リード専有ライト領域（ショートデータ領域）

【配置タイプ13】
	＊ショート定数データ領域をRAMリージョンに置く場合＊
	カーネルドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）
	各ユーザドメインのTA_NOWRITE属性のその他の領域（ショートデータ領域）
	無所属のTA_NOWRITE属性のその他の領域（ショートデータ領域）

【配置タイプ14】
	＊ショート定数データ領域をRAMリージョンに置く場合＊
	カーネルドメインの標準共有定数データ領域（ショートデータ領域）
	各ユーザドメインの標準共有定数データ領域（ショートデータ領域）
	無所属の標準共有定数データ領域（ショートデータ領域）

【配置タイプ15】
	カーネルドメインのTA_NOWRITE属性でないその他の領域（ショートデータ領域）
	各ユーザドメインのTA_NOWRITE属性でないその他の領域（ショートデータ領域）
	無所属のTA_NOWRITE属性でないその他の領域（ショートデータ領域）

【配置タイプ16】
	無所属の標準共有リードライト領域（ショートデータ領域）

【配置タイプ17】
	無所属の標準共有リードライト領域
----------------------------------------

メモリオブジェクトは，まずメモリリージョンによってソートする．具体的に
は，保護ドメイン共通の標準ROMリージョンを最初にし，その後はメモリリー
ジョン番号の順にソートする．これにより，リンカスクリプト中のセクション
生成記述が，メモリリージョンの順になる（メモリ配置がメモリリージョンの
順になるわけではない）．保護ドメイン共通の標準ROMリージョンを最初にす
るのは，初期化データセクションの初期値をこのメモリリージョンに置くため
に，このメモリリージョンの内容を最初に生成したいためである．

各メモリリージョンの中では，配置タイプの順（配置タイプの値が小さいもの
を前）に配置する．

各配置タイプの中では，属する保護ドメイン順（カーネルドメインは最初，無
所属は最後）に配置する．

ただし，レッドゾーン方式を使う場合，ユーザスタック領域については，保護
ドメイン順には並べ換えない．レッドゾーン方式を使う場合のユーザスタック
領域の配置順序については，次の節で述べる．レッドゾーン方式を使わない場
合，ユーザスタック領域は，保護ドメイン順に並び換えた後，タスクID順に配
置する．

さらに，各保護ドメインの中では，以下の順で配置する（ユーザスタック領域
は除く）．

・TA_EXEC，TA_MEMINI，TA_MEMZERO以外のメモリオブジェクト属性の値の順
・それも同じ場合には，acptn1の値の順
・それも同じ場合には，acptn2の値の順
・それも同じ場合には，acptn4の順（無所属以外では標準のacptn4が最初，無
　所属では標準のacptn4が最後，標準でないacptn4の間ではacptn4の値の順）
・それも同じ場合には，TA_EXECが設定されているものを前，設定されていな
　いものを後
・それも同じ場合には，TA_MEMINI，TA_MEMZERO，TA_NULLの順
・それも同じ場合には，静的APIの記述順

●レッドゾーン方式におけるユーザスタック領域の配置順序の決定

レッドゾーン方式を用いる場合には，同じ保護ドメインに属するタスクのユー
ザスタック領域が連続して配置されないようにする（アプリケーションでユー
ザスタック領域の先頭番地が指定されたタスクは除く）．1つの保護ドメイン
に属するタスクの数が多く，ユーザスタック領域だけではそのような配置が実
現できない場合には，ダミースタック領域を設ける．

具体的な配置方法は以下の通り．

保護ドメインの中で，最も多くのユーザタスク（アプリケーションでユーザス
タック領域の先頭番地が指定されたものは除く．以下同じ）が属するものを，
DOM_Mとする．

ユーザタスクの数の合計が偶数で，そのちょうど半分が，DOM_Mに属する場合
は，次のように配置すればよい．

	DOM_1, DOM_M, DOM_2, DOM_M, DOM_3, DOM_M, DOM_4, DOM_M

ユーザタスクの数の合計が奇数で，その半分（切り上げ）が，DOM_Mに属する
場合は，次のように配置すればよい．

	DOM_M, DOM_1, DOM_M, DOM_2, DOM_M, DOM_3, DOM_M, DOM_4, DOM_M

DOM_Mに属するユーザタスクの数がこれより多いと，ダミースタック領域を追
加する必要がある．このことから，必要となるダミースタック領域の数は，以
下の式で求めることができる．

	DOM_Mに属するユーザタスクの数 × 2 - 1 - ユーザタスクの数の合計

まず，この式で求まる数のダミースタック領域を確保する．この時，ダミース
タック領域は，保護ドメインに属さないもの（無所属）とする．

★未完成★

●メモリオブジェクト／セクション／メモリ保護単位のラベル

カーネルがメモリオブジェクト／セクション／メモリ保護単位の番地を取得す
るために，それらの先頭番地／終了番地／アラインした終了番地にラベルを置
く．ラベルのシンボルは次のように付与する．

	先頭番地
		__start_<セクションのラベル>
		__start_<メモリオブジェクトのラベル>
		__start_<メモリ保護単位のラベル>

	終了番地（使用している最後の番地の次の番地）
		__end_<セクションのラベル>
		__end_<メモリオブジェクトのラベル>
	 ※ 終了番地という用語は，メモリ領域内の最後の番地を指す場合と，そ
	 	の次の番地を指す場合があるが，ここでは後者の意味で用いる．

	アラインした終了番地（終了番地をアラインさせた番地）
		__aend_<メモリオブジェクトのラベル>
		__aend_<メモリ保護単位のラベル>

これらのラベル名に含まれる<セクションのラベル>，<メモリオブジェクトの
ラベル>，<メモリ保護単位のラベル>は，以下のように定める（ここで言うセ
クションは，リンク後セクションである）．

タスクのユーザスタック領域に対しては，<セクションのラベル>，<メモリオ
ブジェクトのラベル>，<メモリ保護単位のラベル>とも，セクション名
（.ustack_<タスク名>）の先頭の"."を削除したものとする．

その他の領域については，以下の通り．

<セクションのラベル>は，以下の(1)〜(7)の要素を"_"で接続したものとする．
通常操作1，通常操作2，参照操作のアクセス許可パターンがすべて標準的なも
のである場合，(5)〜(7)の要素は省略する．要素を省略する場合には，それを
つなぐ"_"も省略する．

<メモリオブジェクトのラベル>は，"mo"と以下の(1)(2')(3)(4')(5)〜(7)の要
素を"_"で接続したものとする．通常操作1，通常操作2，参照操作のアクセス
許可パターンがすべて標準的なものである場合，(5)〜(7)の要素は省略する．
また，標準共有リード専有ライト領域の場合は，(5)〜(6)の要素は省略する．
また，標準共有リード専有ライト領域の場合，(5)(6)の要素は省略する．要素
を省略する場合には，それをつなぐ"_"も省略する．

<メモリ保護単位のラベル>は，"mp"と以下の(1)(2')(3)(4')(5)(6)の要素を
"_"で接続したものとする．通常操作1と通常操作2のアクセス許可パターンが
標準的なものである場合と，標準共有リード専有ライト領域の場合は，(5)〜
(6)の要素は省略する．要素を省略する場合には，それをつなぐ"_"も省略する．

(1) メモリリージョン名

メモリオブジェクトの配置先のメモリリージョンの名称．TA_NOWRITE属性のメ
モリオブジェクトが標準ROMリージョンに配置される場合と，TA_NOWRITE属性で
ないメモリオブジェクトが標準RAMリージョンに配置される場合には，この要素
を省略する．

(2) セクション種別

次の5つの文字列か，これらの文字列の前に"s"を付加した文字列のいずれか．
この要素を省略することはない．

	"text"：メモリオブジェクト属性に，TA_NOWRITE属性とTA_EXECが設定さ
			れている場合
	"rodata"：メモリオブジェクト属性に，TA_NOWRITE属性が設定されていて，
			  TA_EXECが設定されていない場合
	"data"：メモリオブジェクト属性に，TA_NOWRITE属性が設定されておらず，
			TA_MEMINIが設定されている場合
	"bss"： メモリオブジェクト属性に，TA_NOWRITE属性が設定されておらず，
			TA_MEMZEROが設定されている場合
	"noinit"：メモリオブジェクト属性に，TA_NOWRITE属性が設定されておら
			  ず，TA_MEMINIもTA_MEMZEROも設定されていない場合

メモリオブジェクト属性にTA_SDATAが設定されている場合には，上記の文字列
の前に"s"を付加する．

(2') メモリオブジェクト種別

次の4つの文字列か，これらの文字列の前に"s"を付加した文字列のいずれか．
この要素を省略することはない．

	"text"：メモリオブジェクト属性に，TA_NOWRITE属性とTA_EXEC属性が設
			定されている場合
	"rodata"：メモリオブジェクト属性に，TA_NOWRITE属性が設定されていて，
			  TA_EXEC属性が設定されていない場合
	"rwdata"：メモリオブジェクト属性に，TA_NOWRITE属性が設定されていな
			  い場合（標準共有リード専有ライト領域を除く）
	"srpw"：標準共有リード専有ライト領域の場合

メモリオブジェクト属性にTA_SDATAが設定されている場合には，上記の文字列
の前に"s"を付加する．

"text"と"rodata"を区別するのは，TA_EXEC属性の有無により標準的なメモリ
オブジェクト属性が違うことから，標準コード領域と標準定数データ領域を区
別するために必要なためである．さらに，標準共有リード専有ライト領域の場
合に別の文字列にするのは，標準共有リード専有ライト領域に対しては(5)と
(6)を省略するため，標準専有リードライト領域と区別がつかなくなるためで
ある。

(3) 保護ドメイン名

メモリオブジェクトが属する保護ドメインの名称．カーネルドメインの場合は
"kernel"，無所属の場合は"shared"とする．この要素を省略することはない．

(4) メモリオブジェクト属性

メモリオブジェクト属性の値を16進数で表現したものの前に"A"を付けたもの．
メモリオブジェクト属性が標準的なものである場合には，この要素は省略する．

(4') メモリオブジェクトアクセス属性

メモリオブジェクトアクセス属性の値を16進数で表現したものの前に"A"を付
けたもの．メモリオブジェクトアクセス属性が標準的なものである場合には，
この要素は省略する．

(5) 通常操作1のアクセス許可パターン

通常操作1のアクセス許可パターン（acptn1）がTACP_SHAREDの場合は"S"，そ
れ以外の場合は，その値を16進数で表現したもの．メモリオブジェクトが
TA_NOWRITE属性の場合には，この要素は省略する．

(6) 通常操作2のアクセス許可パターン

通常操作2のアクセス許可パターン（acptn2）がTACP_SHAREDの場合は"S"，そ
れ以外の場合は，その値を16進数で表現したもの．

(7) 参照操作のアクセス許可パターン

参照操作のアクセス許可パターン（acptn4）がTACP_SHAREDの場合は"S"，それ
以外の場合は，その値を16進数で表現したもの．参照操作のアクセス許可パター
ンが標準的なものである場合には，この要素は省略する．

以上の規則で決定されるセクション／メモリオブジェクト／メモリ保護単位の
ラベルの例を挙げる．

例1）カーネルドメインにATT_MODで登録したオブジェクトモジュールのコード
セクション（メモリオブジェクト属性は標準になっている）

	<セクションのラベル>			text_kernel
	<メモリオブジェクトのラベル>	mo_text_kernel
	<メモリ保護単位のラベル>		mp_text_kernel

例2）カーネルドメインに，通常操作2と参照操作のアクセス許可パターンに
0x01を指定してATT_MODで登録したオブジェクトモジュールの定数データセクショ
ン（通常操作1のアクセス許可パターンは無視される．メモリオブジェクト属性
は標準になっている）

	<セクションのラベル>			rodata_kernel_1_1
	<メモリオブジェクトのラベル>	mo_rodata_kernel_1_1
	<メモリ保護単位のラベル>		mp_rodata_kernel_1

例3）カーネルドメインに，通常操作1のアクセス許可パターンに0x01，通常操
作2のアクセス許可パターンにTACP_KERNEL，参照操作のアクセス許可パターン
にTACP_SHAREDを指定して，ATT_MODで登録したオブジェクトモジュールの初期
化データセクション（メモリオブジェクト属性は標準になっている）

	<セクションのラベル>			data_kernel_1_0_S
	<メモリオブジェクトのラベル>	mo_rwdata_kernel_1_0_S
	<メモリ保護単位のラベル>		mp_rwdata_kernel_1_0

例4）保護ドメインIDが1の保護ドメインDOM1に，通常操作1のアクセス許可パ
ターンにTACP(DOM1)，通常操作2のアクセス許可パターンにTACP_SHARED，参照
操作のアクセス許可パターンにTACP(DOM1)を指定してATT_MODで登録したオブ
ジェクトモジュールのクリアデータセクション（メモリオブジェクト属性は標
準になっている）

	<セクションのラベル>			bss_DOM1_1_S_1
	<メモリオブジェクトのラベル>	mo_rwdata_DOM1_1_S_1
	<メモリ保護単位のラベル>		mp_rwdata_DOM1_1_S

例5）無所属のメモリオブジェクトとして，配置先のメモリリージョンに標準
RAMリージョンを，メモリオブジェクト属性にTA_UNCACHEを指定し，ATT_SECで
登録したセクション（アクセス許可ベクタは標準になっている）

	<セクションのラベル>			noinit_shared_A40
	<メモリオブジェクトのラベル>	mo_rwdata_shared_A40
	<メモリ保護単位のラベル>		mp_rwdata_shared_A40

例6）カーネルドメインに，配置先のメモリリージョンに"ROM2"（ROM2は
TA_NOWRITE属性のメモリリージョンであることを想定）を，メモリオブジェク
ト属性にTA_NOWRITE|TA_EXEC，通常操作2のアクセス許可パターンに0x02，参照
操作のアクセス許可パターンにTACP_KERNELを指定して，ATT_SECで登録したセ
クション

	<セクションのラベル>			ROM2_text_kernel_2
	<メモリオブジェクトのラベル>	mo_ROM2_text_kernel_2
	<メモリ保護単位のラベル>		mp_ROM2_text_kernel_2

●dataセクションとbssセクションの初期化

HRP3カーネルでは，dataセクションとbssセクションが複数生成される．自動
メモリ配置では，コンフィギュレータはどのメモリ領域がdataセクション／
bssセクションであるかを把握しているため，これらのセクションを初期化す
る機能をカーネルで用意する．

具体的には，初期化すべきdataセクションとbssセクションに関する情報を
kernel_mem.c中に生成し，それを用いてこれらのセクションの初期化を行う関
数initialize_sectionsを用意する．initialize_sectionsは，スタートアップ
モジュールから呼び出すことを想定する（カーネル内からは呼び出さない）．

この内，dataセクションの初期化は，プログラムをROM化する場合に対応する
ためのもので，プログラム（データ領域を含む）をストレージ等からメモリに
ロードする場合には必要ない．そのため，OMIT_IDATAをマクロ定義することで，
dataセクションの初期化のための処理を外すことができるようにする．

プログラムをメモリにロードするターゲットでは，標準ROMリージョンを，標
準RAMリージョンを同じメモリリージョンに設定するのが素直である．このよ
うな場合には，dataセクションの初期化を外して（OMIT_IDATAをマクロ定義し
て）使用することとする．ただし，dataセクションはプログラムを実行すると
書き換わるため，dataセクションの初期化を外した場合には，プログラムをロー
ドした後に，複数回実行することはできない（逆に言うと，実行の度にロード
しなければならない）．

1回のロードで複数回実行できるようにするために，dataセクションの初期化
を行うことが必要であるが，標準ROMリージョンと標準RAMリージョンを同じに
していると，正しく動作しない．これは，GNU開発環境のリンカでは，dataセ
クションの内容を同じメモリリージョン内の別の場所にロードすることが，
（少なくとも，素直な方法では）できないためである．

上記の正しく動作しない場合（dataセクションの初期化を行う設定で，標準
ROMリージョンと標準RAMリージョンを同じにした場合）を放置するわけにはい
かないので，コンフィギュレータでエラーを検出するか，dataセクションの初
期化を行わないという仕様にする必要がある．ただし，標準メモリリージョン
は保護ドメイン毎に設定できるため，「標準ROMリージョンと標準RAMリージョ
ンが同じ」も保護ドメイン毎の条件である．そこで，dataセクションの初期化
を行わない条件を，保護ドメイン毎に変化しない条件に置き換えて，次の仕様
とする．

	保護ドメイン共通の標準ROMリージョンがTA_NOWRITE属性でない場合には，
	初期化データは配置されず，メモリオブジェクトの初期化は行われない
	［NGKI3984］．

この仕様では，プログラムをストレージ等から標準RAMリージョンにロードし，
他のRAMリージョンを標準RAMリージョンから初期化するというユースケースに
対応できない．このようなユースケースに対応するには，OMIT_IDATAという一
律の仕組みでは対応できず，メモリリージョン属性にロード対象のメモリリー
ジョンであることを示す属性を導入するといった拡張が必要でありため，現時
点では対応しないこととする．

プログラムをメモリにロードするターゲットで，1回のロードで複数回実行で
きるようにするには，メモリをROMとみなすリージョンとRAMとみなすリージョ
ンに分け，標準ROMリージョンと標準RAMリージョンを別のメモリリージョンと
して，dataセクションの初期化を行う（OMIT_IDATAをマクロ定義しない）方法
を用いることとする．

なお，OMIT_IDATAは，アプリケーションがdataセクションの初期化に依存しな
いように作られている場合（より具体的には，静的変数を（0以外に）初期化
する機能を使用していない場合）にも活用することができる．

○コンフィギュレーション処理手順

HRP3カーネルにおけるコンフィギュレータの処理手順は，統合仕様書 2.12.5
節に記載されている通りである．

メモリ保護のための設定情報を，kernel_cfg.cに生成せず，kernel_mem.cに生
成するのは，kernel_cfg.cにすべてのコンフィギュレーション情報を生成する
と，パス3およびパス4において，kernel_cfg.c全体を再度生成する必要があり，
効率が悪いためである．

なお，コンフィギュレーション手順の各パスにおいて，メモリ保護のための設
定情報がどのように決定されているかについては，「メモリに関するコンフィ
ギュレーション手順（hrp3_memory_proc.txt）」を参照すること．

○時間パーティショニングのベース時刻／時間とタイマの使い方

●システム周期とタイムウィンドウのベース時刻／時間

時間パーティショニングの実現のためには，システム周期とタイムウィンドウ
の管理を，どの時刻／時間をベースとして行うかを決めること（仕様の詳細化）
が必要である．

TOPPERS第3世代カーネル（ITRON系）統合仕様書では，システム時刻に加えて，
プロセッサ時間の概念を導入している．システム時刻は，TOPPERS第3世代カー
ネル（ITRON系）で新たに導入した外部時刻同期機能を用いて，外部の時刻と
同期させることができる．それに対して，プロセッサ時間は，システム時刻の
経過とは独立な時間で，システム時刻の調整やドリフトの調整によって進み方
が変わることはないものとしている．

システム周期については，外部時刻同期機能を用いて外部の時刻と同期させた
い場合が考えられることから，システム時刻をベースにする．そこで，システ
ム時刻を用いた周期ハンドラと同等の機構により，システム周期を管理する．

タイムウィンドウの管理については，まず，システム時刻の調整やドリフト量
の設定によってタイムウィンドウが伸び縮みするかどうかがポイントとなる．
時間パーティショニングの趣旨を考えると，タイムウィンドウの長さは，その
パーティションの処理を行うために必要な時間であることから，システム時刻
の調整やドリフト量の設定により伸び縮みしない方が妥当と考えられる．そこ
で，タイムウィンドウの長さはドリフトにより伸び縮みしないという仕様とす
る．

この仕様では，adj_timやset_dftによりシステム周期の外部時刻同期を行う場
合には，伸び縮みするのはアイドルウィンドウであるため，アイドルウィンド
ウの長さの調整で外部時刻との同期を行うということになる．

●時間パーティショニング実現のためのタイマの使い方

システム周期は，システム時刻をベースにすることから，システム時刻を管理
するための高分解能タイマを用いて管理することになる．

使用するハードウェアリソース（タイマ）を最小限とするためには，同一の高
分解能タイマで，タイムウィンドウの管理が行えると都合が良い．さらに，同
一の高分解能タイマが，オーバランハンドラ機能の実現にも使用できるのが理
想的である．

しかし，ASP3カーネルのオーバランハンドラ機能拡張では，オーバランハンド
ラ機能用には，専用のオーバランタイマを用いている．詳細は「参考：高分解
能タイマとオーバランタイマの統合が難しい理由」の節に示すが，オーバラン
ハンドラ機能を高分解能タイマで実現することは，不可能ではないにしても，
オーバヘッドが大きいなどの問題があり，少なくともタイマを多く持つターゲッ
トシステムでは，ムダが大きい．そこで，ターゲット非依存部は高分解能タイ
マとオーバランタイマが独立に存在するとして実装し，1つのタイマで両方実
現することはターゲット依存部に任せる方針とした．

これと同様の議論がタイムウィンドウの管理にも当てはまることから，ターゲッ
ト非依存部は，タイムウィンドウの管理専用の「タイムウィンドウタイマ」が
存在するものとして実装し，タイマの統合はターゲット依存部に任せる方針と
する．

なお，タイムウィンドウタイマとオーバランタイマは，いずれもプロセッサ時
間を計測するためのものであるため，その両者の統合は，システム時刻を管理
するための高分解能タイマとの統合よりは，実現しやすいものと考えられる．
ターゲット依存部で，タイムウィンドウタイマとオーバランタイマを統合する
方法については，今後の課題とする．

●参考：高分解能タイマとオーバランタイマの統合が難しい理由

高分解能タイマとオーバランタイマでは，動作している期間が異なる．具体的
には，（高分解能タイマ以外の）割込みハンドラの実行中は，オーバランタイ
マは動作停止しているが，高分解能タイマは動作している．

そのため，タイマの設定のタイミングも異なる．高分解タイマの設定は，次に
発生するタイムイベントが変化した時と，高分解タイマ割込みハンドラの出口
で行われる．それに対して，オーバランタイマの設定は，オーバランハンドラ
の動作開始／停止時と，すべての割込みハンドラの出口で行われる．

1つのハードウェアタイマで両者を実装する場合で，オーバランタイマの方がイ
ベント発生までの時間が短く，ハードウェアタイマにはオーバラン発生までの
時間が設定されている場合を考える．ここで（タイマ以外の）割込みが発生す
ると，その入口処理においてオーバランタイマを停止させたいが，代わりに高
分解能タイマの設定値を設定する必要がある．現状の時間管理（特に，ドリフ
ト調整機能をサポートする場合）の方法では，高分解能タイマの設定値の計算
は計算量が多く，これを割込み発生の度に行うと，オーバヘッドが大きくなる
のが避けられない．

ただし，時間管理（特に，ドリフト調整機能をサポートする場合の高分解能タ
イマの設定値の計算ロジック）の方法を，オーバランハンドラとの統合を前提
に検討すると，異なる結論となる可能性もある．また，タイマの設定誤差を許
容してよいという立場であれば，統合することも可能であろうと思われる．

※ 過去に，高分解タイマとオーバランタイマの統合を検討して断念した経緯が
あるが，検討記録が残っていないと思われるため，再度検討した．

●タイムウィンドウタイマの操作と割込み処理

タイムウィンドウタイマの操作のために，ターゲット依存部で以下の機能を用
意する．

(1) void target_twdtimer_initialize(intptr_t exinf)

タイムウィンドウタイマの初期化処理を行う．タイマの動作開始は行わない．

この関数は，target_timer.cfg中に記述する静的APIにより，初期化ルーチン
としてカーネルに登録する．そのため，ターゲット依存で関数名を変更しても
差し支えない．

(2) void target_twdtimer_terminate(intptr_t exinf)

タイムウィンドウタイマを停止させ，タイムウィンドウタイマ割込みを発生し
ないようにする．

この関数は，target_timer.cfg中に記述する静的APIにより，終了処理ルーチ
ンとしてカーネルに登録する．そのため，ターゲット依存で関数名を変更して
も差し支えない．

(3) void target_twdtimer_start(PRCTIM twdtim)

タイムウィンドウタイマを，twdtimで指定した時間が経過したら割込みが発生
するように設定し，動作開始する．twdtimが0の場合は，できる限り早くタイ
ムウィンドウタイマ割込みを発生させる．twdtimの単位はマイクロ秒とする．

(4) PRCTIM target_twdtimer_stop(void)

タイムウィンドウタイマを停止し，タイマの残り時間（割込み発生までの時間）
を返す．残り時間がなくなっていた場合には，0を返す．また，タイムウィン
ドウタイマからの割込み要求をクリアする（クリアしないと不要な割込みが発
生するが，クリアすることは必須ではない）．

(7) PRCTIM target_twdtimer_get_current(void)

タイムウィンドウタイマの残り時間（割込み発生までの時間）を読み出す．残
り時間がなくなっていた場合には，0を返す．タイムウィンドウタイマからの
割込みはクリアしない．

(7) void target_twdtimer_handler(void)
    または void target_twdtimer_isr(intptr_t exinf)

タイムウィンドウタイマ割込みにより起動される割込み処理プログラム．割込
みハンドラとして実現する場合にはtarget_twdtimer_handler，割込みサービ
スルーチンとして実現する場合にはtarget_twdtimer_isrの名称とする．ター
ゲット非依存部のtwd_switchを呼び出す．

target_twdtimer_handlerは，標準的には次のように定義する．

----------------------------------------
void
target_twdtimer_handler(void)
{
	タイムウィンドウタイマ割込み要求のクリア（必要なら）
	twd_switch();					/* タイムウィンドウ切換え処理 */
}
----------------------------------------

この関数は，target_timer.cfg中に記述する静的APIにより，割込みハンドラ
または割込みサービスルーチンとしてカーネルに登録する．そのため，ターゲッ
ト依存で関数名を変更しても差し支えない．

○時間パーティショニング下でのタスクスケジューリング

●スケジューリング単位

時間パーティショニング機能の導入により，タスクのスケジューリングは，以
下のグループ毎に行われる．

　・カーネルドメインに属するタスク
　・タイムウィンドウを割り当てられたユーザドメインに属するタスク
　・アイドルドメイン（タイムウィンドウを割り当てられていないユーザドメ
　　インを1つにまとめたもの）に属するタスク

このグループを，スケジューリング単位と呼ぶ．すなわち，カーネルドメイン
に対応するスケジューリング単位（1つだけ），タイムウィンドウを割り当て
られたユーザドメインに対応するスケジューリング単位（該当するユーザドメ
インと同じ数），アイドルドメインに対応するスケジューリング単位（1つだ
け）が存在することになる．

各スケジューリング単位に属するタスクをスケジュールするために，スケジュー
リング単位管理ブロック（SCHEDCB）を設けて，以下の情報を管理する．

　・優先順位が最も高いタスク（p_predtsk）
　・レディキュー（ready_queue）
　・レディキューサーチのためのビットマップ（ready_primap）

ここで，優先順位が最も高いタスク（p_predtsk）は，レディキューの中で最
も優先順位の高いタスクのTCBを指すポインタである．システム全体の実行す
べきタスク（p_schedtsk）と異なり，ディスパッチ禁止フラグと割込み優先度
マスクの影響は受けない．これは，ディスパッチ禁止フラグと割込み優先度マ
スクは，スケジューリング単位毎に持たない仕様としたためである．なお，
p_predtskは，"task with highest precedence"の意味である．

スケジューリング単位管理ブロックを格納する変数および配列として，以下を
設ける．

SCHEDCB		schedcb_kernel;		/* カーネルドメインに対応するスケジュー
								   リング単位管理ブロック */
SCHEDCB		schedcb_table[];	/* タイムウィンドウを割り当てられたユー
								   ザドメインに対応するスケジューリング
								   ドメイン管理ブロックの配列
SCHEDCB		schedcb_idle;		/* アイドルドメインに対応するスケジュー
								   リング単位管理ブロック */

時間パーティショニングを使用しない場合，すべてのユーザドメインはアイド
ルドメインに属するものと扱う．すなわち，時間パーティショニングを使用し
ない場合には，カーネルドメインに対応するものとアイドルドメインに対応す
るものの，2つのスケジューリング単位のみ存在する．

----------------------------------------
【採用しなかった仕様】

当初，ディスパッチの禁止（dis_dsp）は，同じスケジューリング単位内で他
のタスクへ切り換えるのを抑止するものとしていた．つまり，ディスパッチを
禁止しても，他のスケジューリング単位には切り換わるものとしていた．

しかし，この仕様では，次のような面倒な状況が発生する．ディスパッチ禁止
状態において他の保護ドメインに切り換わると，他の保護ドメインからディス
パッチ禁止状態の保護ドメインに属するタスクに対して，sus_tskやter_tskが
発行できるため，タスクが過渡的な状態になってしまう．ter_tskに伴う過渡的
な状態は排除したので，これを再導入したくないことから，この仕様は採用し
ないこととした．
----------------------------------------

●実行すべきタスクの更新

実行すべきタスク（p_schedtsk）は，各スケジューリング単位において優先順
位が最も高いタスク（p_predtsk）を元に，次のように決定する．

(1) 時間パーティショニングを使用しない場合

実行できるすべてのタスクの中で，最も優先順位が高いものを，実行すべきタ
スクとする［NGKI0203］．ここで，カーネルドメインに属するタスクとユーザ
ドメインに属するタスクが同一の優先度を持つ場合には，カーネルドメインに
属するタスクが高い優先順位を持つ［NGKI0588］．

(2) システム周期停止モードの場合

カーネルドメインに属する実行できるタスクの中で，最も優先順位が高いもの
を，実行すべきタスクとする［NGKI0599］．

(3) タイムウィンドウ（アイドルウィンドウを除く）の実行中

カーネルドメインまたはそのタイムウィンドウを割り当てられたユーザドメイ
ンに属する実行できるタスクの中で，最も優先順位が高いものを，実行すべき
タスクとする［NGKI0591］．(1)の場合と同様，カーネルドメインに属するタ
スクとアイドルドメインに属するタスクが同一の優先度を持つ場合には，カー
ネルドメインに属するタスクが高い優先順位を持つ［NGKI0588］．

これらの保護ドメインに属する実行できるタスクがない場合には，アイドルド
メインに属する実行できるタスクの中で，最も優先順位が高いものを，実行す
べきタスクとする［NGKI0592］．

(4) アイドルウィンドウの実行中

カーネルドメインまたはアイドルドメインに属する実行できるタスクの中で，
最も優先順位が高いものを，実行すべきタスクとする［NGKI0595］．(1)の場
合と同様，カーネルドメインに属するタスクとアイドルドメインに属するタス
クが同一の優先度を持つ場合には，カーネルドメインに属するタスクが高い優
先順位を持つ［NGKI0588］．

各スケジューリング単位の優先順位が最も高いタスク（p_predtsk）を元に，
実行すべきタスク（p_schedtsk）を更新する関数（update_schedtsk）は，(1)〜
(4)のすべての場合に対応できるようにする．処理が最も複雑なのは(3)の場合
であるため，(3)の場合に合わせて以下の処理内容の関数を用意する．

----------------------------------------
if (カーネルドメインに実行できるタスクがある)
	if (「現在スケジューリング単位」に実行できるタスクがある，かつ
				「現在スケジューリング単位」のp_predtskの優先度が
				カーネルドメインのp_predtskの優先度より高い)
		p_schetsk ←「現在スケジューリング単位」のp_predtsk
	else
		p_schetsk ← カーネルドメインのp_predtsk
else
	if (「現在スケジューリング単位」に実行できるタスクがある)
		p_schetsk ←「現在スケジューリング単位」のp_predtsk
	else
		p_schetsk ←「アイドル時スケジューリング単位」のp_predtsk
----------------------------------------

ここで，(3)の場合には，「現在スケジューリング単位」を実行中のタイムウィ
ンドウを割り当てられたユーザドメインに，「アイドル時スケジューリング単
位」をアイドルドメインとする．

(1)の場合には，すべてのユーザドメインがアイドルドメインにまとめられる
ため，「現在スケジューリング単位」をカーネルドメイン，「アイドル時スケ
ジューリング単位」をアイドルドメインとすることで，上の更新処理を流用で
きる．

(2)の場合には，「現在スケジューリング単位」と「アイドル時スケジューリ
ング単位」の両方をカーネルドメインとすることで，上の更新処理を流用でき
る．

(4)の場合には，「現在スケジューリング単位」と「アイドル時スケジューリ
ング単位」の両方をアイドルドメインとすることで，上の更新処理を流用でき
る．

以上より，(1)〜(4)の場合に応じて「現在スケジューリング単位」と「アイド
ル時スケジューリング単位」を適切に設定することで，上記の処理内容の
update_schedtsk関数で，(1)〜(4)のすべての場合に対応できる．

「現在スケジューリング単位」と「アイドル時スケジューリング単位」は，以
下のグローバル変数に設定する．

SCHEDCB	*p_twdsched;		/* 現在スケジューリング単位 */
SCHEDCB	*p_idlesched;		/* アイドル時スケジューリング単位 */

update_schedtsk関数の呼び出しは，「現在スケジューリング単位」または
「アイドル時スケジューリング単位」が変化した時と，いずれかのスケジュー
リング単位において優先順位が最も高いタスク（p_predtsk）が変化した時に，
ディスパッチ可能状態（dspflgがtrueの状態）であれば行う．また，ディスパッ
チ可能状態に遷移した時（dspflgがfalseからtrueになった時）にも，この処
理を行う．

●タイムウィンドウタイマの動作開始／停止タイミング

タイムウィンドウタイマでは，実行中のタイムウィンドウで，カーネルドメイ
ンに属する処理単位以外の処理単位が実行している時間を計測したい．具体的
には，割込みハンドラ，CPU例外ハンドラ，カーネルドメインに属するタスクの
実行時間は計測せず，ユーザドメイン（タイムウィンドウを割り付けられた保
護ドメインおよびアイドルウィンドウに含まれる保護ドメイン）に属するタス
クの実行時間と，どのタスクも実行していない時間の合計時間を計測する．

このことから，タイムウィンドウタイマを動作開始／停止するタイミングを明
らかにする．まずは，ユーザドメインに属するタイムイベント処理（周期通知，
アラーム通知，タイムアウト処理，時間経過待ち状態からの待ち解除処理）に
ついては除外して検討する．

停止するタイミング：
(a) 割込み／CPU例外ハンドラの入口
(b) ユーザドメインに属するタスクが呼び出したサービスコールにより，カー
	ネルドメインに属するタスクに切り換える時

動作開始するタイミング：
(c) 割込み／CPU例外ハンドラの出口で，ユーザドメインに属するタスクへリ
	ターンする時
(d) 割込み／CPU例外ハンドラの出口で，ディスパッチャ内のアイドル処理へリ
	ターンする時（p_runtskがNULLの時）
(e) カーネルドメインに属するタスクが呼び出したサービスコールにより，ユー
	ザドメインに属するタスクに切り換える時
(f) カーネルドメインに属するタスクが呼び出したサービスコールにより，ディ
	スパッチャ内のアイドル処理へ分岐する時
(g) タイムウィンドウの切り換え後に，ユーザドメインに属するタスクに切り
	換える時
(h) タイムウィンドウの切り換え後に，ディスパッチャ内のアイドル処理へ分
	岐する時

なお，カーネル管理外の割込みでは，タイムウィンドウタイマは停止／動作開
始されない（ユーザにタイムウィンドウタイマを操作することを要求しない）．
また，カーネル管理外のCPU例外では，タイムウィンドウタイマは停止／動作
開始しないこととする．

以下，上記の(a)〜(h)のそれぞれについて，どの処理でタイムウィンドウタイ
マを動作開始／停止するかを検討する．

(a) 割込み／CPU例外ハンドラの入口

割込み／CPU例外の出入口処理で，割込み／CPU例外を受け付けた後，なるべく
早いタイミングでタイムウィンドウタイマを停止したい．そこで，割込み／
CPU例外の出入口処理の先頭で，オーバランタイマを停止するのに合わせて，
タイムウィンドウタイマを停止する．

(b) ユーザドメインに属するタスクが呼び出したサービスコールにより，カー
	ネルドメインに属するタスクに切り換える時

ユーザドメインが呼び出したサービスコールの処理時間は，ユーザドメインの
処理時間と考えるべきである．ディスパッチ処理をユーザドメインの処理に含
めるべきかは微妙であるが，ユーザドメインが呼び出したサービスコールが引
き起こした処理であることから，ユーザドメインの処理時間に含めることとし，
ディスパッチ処理のなるべく遅いタイミングでタイムウィンドウタイマを停止
する．具体的には，dispatch_r，ret_int_r，ret_exc_r，start_stask_rの処
理中で，オーバランタイマを動作開始するのに合わせて，タイムウィンドウタ
イマを停止させる．

----------------------------------------
【採用しなかった検討】

ディスパッチ処理をユーザドメインの処理時間に含めない場合には，ディスパッ
チ処理のなるべく早いタイミング，すなわち，dispatchの中でオーバランタイ
マの停止処理に合わせて，タイムウィンドウタイマを停止させるのが妥当であ
ろう．

そもそも，ユーザドメインからカーネルドメインに属するタスクを起動するこ
とは，時間パーティショニングの抜け道となるため推奨されない（さらに言う
と，カーネルドメインに属するタスクを使用することが推奨されない）ため，
ディスパッチ処理をユーザドメインの処理に含めるべきかは，決めるのが難し
い．
----------------------------------------

(c) 割込み／CPU例外ハンドラの出口で，ユーザドメインに属するタスクへリ
	ターンする時

割込み／CPU例外の出入口処理で，ユーザドメインに属するタスクへリターン
する前の，なるべく遅いタイミングでタイムウィンドウタイマを動作開始する．
具体的には，割込み／CPU例外の出入口処理のタスクへのリターン処理で，オー
バランタイマを動作開始するのに合わせて，リターン先がユーザドメインに属
するタスクであれば，タイムウィンドウタイマを動作開始する．

(d) 割込み／CPU例外ハンドラの出口で，ディスパッチャ内のアイドル処理へリ
	ターンする時（p_runtskがNULLの時）

アイドル処理中に発生したカーネル管理の割込み／CPU例外からは，アイドル
処理にはリターンせず，割込み／CPU例外の出入口処理からdispatcher_0に分
岐する．そこで，dispatcherの中でアイドル処理に入る前に，タイムウィンド
ウタイマを動作開始する．

(e) カーネルドメインに属するタスクが呼び出したサービスコールにより，ユー
	ザドメインに属するタスクに切り換える時

ユーザドメインの処理時間を計測したいことから，カーネルドメインに属する
タスクが呼び出したサービスコールの処理時間は計測対象外とし，ディスパッ
チ処理のなるべく遅いタイミングで，タイムウィンドウタイマを動作開始する．
具体的には，dispatch_r，ret_int_r，ret_exc_r，start_utask_rの処理中で，
オーバランタイマを動作開始するのに合わせて，タイムウィンドウタイマを動
作開始する．

(f) カーネルドメインに属するタスクが呼び出したサービスコールにより，ディ
	スパッチャ内のアイドル処理へ分岐する時

dispatcherの中でアイドル処理に入る前に，タイムウィンドウタイマを動作開
始する．(d)の処理と共通化できる．

(g) タイムウィンドウの切り換え後に，ユーザドメインに属するタスクに切り
	換える時

タイムウィンドウ切換えは，高分解能タイマ割込みまたはタイムウィンドウタ
イマ割込みで行われるため，(c)と同様に扱うことができる．ただし，現時点
の検討では除外しているユーザドメインに属するタイムイベント処理を考える
と，状況が変わる可能性がある．

(h) タイムウィンドウの切り換え後に，ディスパッチャ内のアイドル処理へ分
	岐する時

タイムウィンドウ切換えは，高分解能タイマ割込みまたはタイムウィンドウタ
イマ割込みで行われるため，(d)と同様に扱うことができる．

以上をまとめると，タイムウィンドウタイマを動作開始／停止する処理を，以
下の処理に入れることになる．

停止する処理：
(a) 割込み／CPU例外ハンドラの入口処理
(b-1) dispatch_r，ret_int_r，ret_exc_rで，カーネルドメインに属するタス
	  クに切り換えた時
(b-2) start_stask_r

動作開始する処理：
(c)(g) 割込み／CPU例外ハンドラの出口処理で，ユーザドメインに属するタス
	   クにリターンする時
(d)(f)(h) dispatcherでアイドル処理に入る前
(e-1) dispatch_r，ret_int_r，ret_exc_rで，ユーザドメインに属するタスク
	  に切り換えた時
(e-2) start_utask_r

なお，アイドルウィンドウにおいては，タイムウィンドウタイマは動作させな
い（動作開始／停止を行わない）．

●タイムウィンドウタイマの動作開始／停止処理コード

タイムウィンドウの時間計測が必要なのは，タイムウィンドウ（アイドルウィ
ンドウを除く）の実行中のみであり，時間パーティショニングを使用しない場
合，システム周期停止モードの場合，アイドルウィンドウの実行中は，タイム
ウィンドウの時間計測は必要ない．そこで，タイムウィンドウの時間計測が必
要であるかどうかを，以下のグローバル変数に保持する．

bool_t	twdtimer_enable;	/* タイムウィンドウタイマを動作させるべき
							   状態であることを示すフラグ */

また，ユーザドメインに属するタスクからユーザドメインに属する他のタスク
に切り換える時には，タイムウィンドウタイマの動作開始は必要ないが，切り
換え前のタスクの種別を判定するのはオーバヘッドが大きくなるため，タイム
ウィンドウタイマが動作中かを以下のグローバル変数に保持し，タイムウィン
ドウタイマが動作中の場合は再度の動作開始は行わないようにする．

bool_t  twdtimer_flag;		/* タイムウィンドウタイマが動作中か */

さらに，タイムウィンドウタイマが停止中（twdtimer_flagがfalseの間）に，
タイムウィンドウの残り時間をグローバル変数に保持する必要があるため，以
下のグローバル変数を設ける．

PRCTIM  left_twdtim;		/* タイムウィンドウの残り時間 */

タイムウィンドウタイマを動作開始／停止させるための関数は次の通り（実際
のコードとは少し異なる）．

----------------------------------------
inline void
twdtimer_start(void)
{
	if (!twdtimer_flag) {
		target_twdtimer_start(left_twdtim);
		twdtimer_flag = true;
	}
}

inline void
twdtimer_stop(void)
{
	if (twdtimer_flag) {
		left_twdtim = target_twdtimer_stop();
		twdtimer_flag = false;
	}
}

void
twdtimer_control(void)
{
	if (p_runtsk == NULL || p_runtsk->p_dominib != &dominib_kernel) {
		twdtimer_start();
	}
	else {
		twdtimer_stop();
	}
}
----------------------------------------

(a)〜(h)の処理に対応するためのコードの修正箇所は次の通り．

----------------------------------------
void
dispatcher(void)
{
	……

	/*
	 *  アイドル処理
	 */
+	if (twdtimer_enable) {
+		twdtimer_start();				/* タイムウィンドウタイマの動作開始 */
+	}
	割込みを許可したらCPUロック解除状態になるよう準備する
	割込みをすべて許可する
	……
}
----------------------------------------
void
dispatch(void)
{
	……

  dispatch_r:
	if (自タスクがユーザタスク) {
		ユーザスタックポインタをスタックから復帰する
	}
	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
	rundomをスタックに保存する
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+	if (twdtimer_enable) {
+		twdtimer_control();				/* タイムウィンドウタイマの切換え */
+	}
}
----------------------------------------
void
activate_context(TCB *p_tcb)
{
	……

  start_stask_r:
	rundom = TACP_KERNEL;
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+	if (twdtimer_enable) {
+		twdtimer_stop();				/* タイムウィンドウタイマの停止 */
+	}
	CPUロック解除状態にする
	自タスク（p_runtsk）の起動番地を，拡張情報をパラメータとして呼び出す
	ext_tskに分岐する ... (*c)

  start_utask_r:
	rundom = p_runtsk->p_dominib->domptn;
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+	if (twdtimer_enable) {
+		twdtimer_start();				/* タイムウィンドウタイマの動作開始 */
+	}
	……
}
----------------------------------------
void
<割込みの出入口処理>(void)
{
	……
	if (割込みがタスクコンテキストで発生) {
+		if (twdtimer_enable) {
+			twdtimer_stop();			/* タイムウィンドウタイマの停止 */
+		}
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_stop();				/* オーバランタイマの停止 */ … (*e)
#endif /* TOPPERS_SUPPORT_OVRHDR */
		……

#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+		if (twdtimer_enable) {
+			twdtimer_control();			/* タイムウィンドウタイマの切換え */
+		}
	}
	……
}
----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	……
	if (カーネル管理外のCPU例外) {
		……
	}
	else {
		if (CPU例外がタスクコンテキストで発生) {
			少なくともカーネル管理の割込みを禁止した状態にする
+			if (twdtimer_enable) {
+				twdtimer_stop();		/* タイムウィンドウタイマの停止 */
+			}
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_stop();			/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
			……

#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_start();		/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
+			if (twdtimer_enable) {
+				twdtimer_control();		/* タイムウィンドウタイマの切換え */
+			}
		}
		CPU例外処理からのリターン後に，CPUロック解除状態に戻るように準備する
	}
	……
}
----------------------------------------

○システム周期とタイムウィンドウの管理

●システム周期切換え処理と実行開始処理

システム周期切換えは，周期ハンドラと同じ機構を用いて，システム周期毎に
システム周期切換え処理（scyc_switch）を呼び出すことで行う．scyc_switch
は，割込みコンテキストで，CPUロック状態で呼び出される．

scyc_switchでは，システム周期の実行開始処理（scyc_start）を呼び出した
後，必要であれば，タスク切換えを行う（実際には，scyc_switchを呼び出し
た高分解能タイマ割込みの出口でタスクを切り換える）．

呼び出されたシステム周期の実行開始処理（scyc_start）では，まず，前の周
期のタイムウィンドウの処理が完了しているか（言い換えると，アイドルウィ
ンドウになっているか）をチェックする．完了していない場合には，システム
周期オーバラン例外を発生させる．

次に，切換え後のシステム周期のシステム動作モードを決定する．

切換え後にシステム周期停止モードに遷移する場合には，「現在スケジューリ
ング単位」と「アイドル時スケジューリング単位」の両方をカーネルドメイン
とする．

そうでない場合には，システム周期時間の経過後に再度システム周期切換え処
理を実行するためのタイムイベントを設定した後，twd_startを呼び出して，
システム周期の最初のタイムウィンドウの実行を開始する．

scyc_startは，scyc_switchに加えて，保留していたシステム周期切換えを実
行する場合と，chg_somによりシステム周期を開始する場合にも呼び出される．
これらについては，それぞれ「システム周期切換えとタイムウィンドウ切換え
の保留」と「chg_somによるシステム周期の開始」の節で後述する．

●タイムウィンドウ切換え処理

タイムウィンドウ切換えは，タイムウィンドウタイマ割込みにより，タイムウィ
ンドウ切換え処理（twd_switch）を呼び出すことで行う（「タイムウィンドウ
タイマの操作と割込み処理」の節を参照）．twd_switchは，割込みコンテキス
トで，CPUロック解除状態で呼び出される．

twd_switchでは，twd_startを呼び出して，実行中のタイムウィンドウの次の
タイムウィンドウの実行を開始した後，必要であれば，タスク切換えを行う
（実際には，タイムウィンドウタイマ割込みの出口でタスクを切り換える）．

なお，twd_switchでは，不必要な割込み（スプリアス割込み）によりタイムウィ
ンドウが切り換わってしまうのを防ぐために，関数の先頭でタイムウィンドウ
切換えが必要であることを確認し，必要ない場合には，タイムウィンドウ切換
えを行わず，システムログにメッセージを出力するように対策している．具体
的には，タイムウィンドウタイマを動作させるべき状態（twdtimer_enableが
true）で，タイムウィンドウの残り時間（left_twdtim）が0の時に，タイムウィ
ンドウ切換えが必要であると判断している．なお，タイムウィンドウタイマ割
込みの入口処理で，タイムウィンドウタイマを停止させるため，twd_switchが
呼ばれた時点では，タイムウィンドウタイマは停止している（twdtimer_flag
はfalseになっている）．

●タイムウィンドウの実行開始処理

タイムウィンドウの実行開始処理（twd_start）は，システム周期の実行開始
と，タイムウィンドウ切換え時に呼び出される．

twd_startでは，まず，実行を開始するタイムウィンドウに応じて，以下の変
数を書き換える（実際には，p_runtwdは，twd_startを呼び出す側で設定する）．
実行すべきタイムウィンドウがない場合には，アイドルウィンドウに切り換え
る．

	p_runtwd		実行中のタイムウィンドウの初期化ブロックを指すポイ
					ンタ. アイドルウィンドウの場合は，NULLに設定する．
	p_twdsched		「現在スケジューリング単位」
	p_idlesched		「アイドル時スケジューリング単位」
	twdtimer_enable タイムウィンドウタイマを動作させるべき状態であるこ
					とを示すフラグ．タイムウィンドウ（アイドルウィンド
					ウを除く）の場合はtrue，アイドルウィンドウの場合は
					falseに設定する．
	left_twdtim		タイムウィンドウの残り時間．タイムウィンドウの長さ
					に設定する．アイドルウィンドウの場合は設定する必要
					がない．

アイドルウィンドウでない場合には，ここで，タイムウィンドウタイマの動作
を開始する．これ以降の時間は，タイムウィンドウに含まれるものと扱われる．

次に，通知ハンドラが登録されている場合には，CPUロック解除状態で通知ハ
ンドラを呼び出す．最後に，タイムイベントの処理を行う．タイムイベントの
処理方法については，次の節で述べる．

----------------------------------------
【採用しなかった方法】

HRP3カーネルの3.0.0まででは，タイムウィンドウ切換え処理は，必ず割込み
のコンテキストで行う実装としていた．これは，システム周期切換え処理を行
う高分解能タイマ割込みの優先度を，タイムウィンドウ割込みの優先度よりも
高くしておくことで，アイドルウィンドウに属するタイムイベントの処理中に，
システム周期切換え処理が実行されたことを検出するためであった．

タイムウィンドウ切換えが必要になった場合には，タイムウィンドウタイマ割
込みを発生させて，タイムウィンドウ切換え処理を起動する．
----------------------------------------

●ユーザドメインに属するタイムイベントの処理

ユーザドメインに属するタイムイベントの処理は，そのユーザドメインに割り
当てられたタイムウィンドウの先頭で処理される［NGKI0600］．アイドルドメ
インに属するタイムイベントの処理は，アイドルウィンドウの先頭で処理され
る［NGKI0601］．

同じタイミングで処理すべきタイムイベントは，一般には複数になり，その数
の上限を抑えることができない（例えば，通知周期の短い周期通知を用いた場
合など）．そのため，タイムイベントの処理だけでタイムウィンドウを使い切
る場合も考えられ，その場合には，タイムイベントの処理を打ち切り，次のタ
イムウィンドウに切り換えなければならない．

ここで，タイムイベントの処理をどのように実行するかに関して，2つの方法が
考えられる．

案1）タイムウィンドウタイマ割込み処理で実行する

タイムウィンドウの切り換えは，（主に）高分解能タイマ割込みとタイムウィ
ンドウタイマ割込みで行うため，タイムイベントの処理は，割込み処理をその
まま継続して行うのが素直である．ただし，上述の通り，タイムイベントの処
理は一般には長い時間を要するため，他の割込みの応答性低下が問題になる．
多重割込みが可能な場合には，これらのタイマ割込みを最低優先度にすること
で，この問題は回避できる．

案2）タイムイベントの処理を実行するためのタスクを用意する

タイムウィンドウの切り換えを行う割込みから，用意したタスクを起動し，用
意したタスクの中で，タイムイベントの処理を実行する．タスクは，スケジュー
リング単位毎に用意する必要があるため，タスク数の増加によるオーバヘッド
が予想される．

HRP3カーネルを用いる規模のターゲットシステムでは，通常，多重割込みをサ
ポートしていると思われることから，オーバヘッドが小さい案1を採用すること
する．

案1を採用する場合，タイムイベントの処理だけでタイムウィンドウを使い切る
場合に，特殊な扱いが必要になる．以下では，これについて検討する．

言うまでもなく，ユーザドメインに属するタイムイベント処理中も，タイムウィ
ンドウタイマを動かしておく必要がある．タイムイベントの処理だけでタイム
ウィンドウを使い切った場合，タイムウィンドウタイマ割込み処理中に再度の
タイムウィンドウタイマ割込みが要求されることになるが，（割込み優先度が
同じであることから）再度のタイムウィンドウタイマ割込みは受け付けられな
い．そこで，タイムイベントを1つ処理する度に，タイムウィンドウを使い切っ
ていないかチェックし，タイムウィンドウを使い切った場合には，タイムイベ
ントの処理を打ち切る．これにより，その直後に，再度のタイムウィンドウタ
イマ割込みが受け付けられ，タイムウィンドウ切換えが行われる．

ただし，アイドルウィンドウにおいてはタイムウィンドウタイマは動作させな
いため，アイドルウィンドウに属するタイムイベントの処理においては，次の
方法で対応する．アイドルウィンドウは，システム周期の終了により終了する
ため，アイドルウィンドウに属するタイムイベントを1つ処理する度に，シス
テム周期切換え時刻になっていないかチェックし，システム周期切換え時刻に
なっていた場合には，タイムイベントの処理を打ち切る．この処理を正しく動
作させるためには，システム周期切換え処理を行う高分解能タイマ割込みの優
先度を，タイムウィンドウタイマ割込みと同じにしておくことが必要である．

また，上述の通り，タイムウィンドウタイマ割込みは最低優先度とするのが望
ましい．

【割込み優先度の設定方法に関する制約】タイムウィンドウタイマ割込みの優
先度は，高分解能タイマ割込みの優先度と同じにしなければならない．また，
これらの割込みの優先度を最低優先度とすることが望ましい．

●ユーザドメインに属するタイムイベントの処理コード

ユーザドメインに属するタイムイベントの処理を行うために，タイムイベント
の処理を打ち切るべきかの判定を行うsuspend_proc_tmevtと，先頭のタイムイ
ベントの処理を行うtmevt_proc_topを設ける．これらを用いてタイムイベント
の処理を行うコードは，次のようになる．

----------------------------------------
	while (!suspend_proc_tmevt() && tmevt_proc_top(p_tmevt_heap)) ;
----------------------------------------

suspend_proc_tmevtは，タイムイベントの処理を打ち切るべき場合にtrue，そ
うでない場合にfalseを返す．

tmevt_proc_topでは，現在のイベント時刻を求めた後，処理すべきタイムイベ
ントヒープの先頭のタイムイベントをチェックし，その発生時刻になっていた
場合には，そのタイムイベントをヒープから削除し，処理を行った後，trueを
返す．先頭のタイムイベントの発生時刻になっていない場合には，falseを返
す．

なお，タイムイベントの処理においては，CPUロック状態を一時的に解除し，
優先度の高い割込みを受け付ける．

●システム周期切換えとタイムウィンドウ切換えの保留

ディスパッチ保留状態では，システム周期の切換えとタイムウィンドウの切換
えは保留される［NGKI0602］．

これを実現するために，ディスパッチ保留状態でシステム周期割込みが発生し
たことを示すフラグ（pending_scycswitch）と，タイムウィンドウタイマ割込
みが発生したことを示すフラグ（pending_twdswitch）を用意する．システム
周期切換え処理／タイムウィンドウ切換え処理の割込みにおいて，ディスパッ
チ保留状態であった場合には，対応する変数をtrueにする．CPUロック状態で
はこれらの割込みは受け付けられないため，ディスパッチ保留状態であること
は，dspflgがfalseであることで判定してよい．

一方，ディスパッチ保留状態を解除する処理，具体的には，ena_dsp，chg_ipm
（割込み優先度マスクを全解除する場合），exk_tsk（ディスパッチ禁止状態を
解除または割込み優先度マスクを全解除する場合）では，保留されているシス
テム周期の切換えとタイムウィンドウの切換えを実行する．

具体的には，これらの処理においてpending_scycswitchがtrueであった場合に
は，scyc_startを呼び出して，システム周期の実行開始処理を行う．また，
pending_twdswitchがtrueであった場合には，twd_startを呼び出して，実行中
のタイムウィンドウの次のタイムウィンドウの実行を開始する．

pending_scycswitchとpending_twdswitchの両方がtrueの場合には，システム
周期の実行開始処理のみを行う．これは，システム周期の実行開始処理を行う
ことで，（必要なら）タイムウィンドウの実行開始も行われるためである．

なお，pending_scycswitchとpending_twdswitchの両方がtrueになるのは，シ
ステム周期オーバランが発生した場合に限られる．なぜなら，システム周期割
込みが発生するのは，システム周期オーバランが発生しない限りアイドルウィ
ンドウの実行中であるのに対して，アイドルウィンドウの実行中はタイムウィ
ンドウタイマを動作させない（よって，タイムウィンドウタイマ割込みは発生
しない）ためである．

保留されているシステム周期の切換えとタイムウィンドウの切換えを実行する
処理は，タスクディスパッチ可能状態への遷移処理を行う関数（set_dspflg）
に含める．

●chg_somによるシステム周期の開始

システム動作モードを変更するサービスコールであるchg_somは，現在のシス
テム動作モードがシステム周期停止モード（TSOM_STP）でない場合には，次の
システム周期を実行開始する時に，指定したシステム動作モードに切り換わる
［NGKI5036］．そのため，次のシステム動作モードを示す変数（p_nxtsom）を，
指定したシステム動作モードに設定するだけでよい．

それに対して現在のシステム動作モードがシステム周期停止モード（TSOM_STP）
である場合には，即座に指定したシステム動作モードに切り換わる［NGKI5037］．
以下では，この切り換え処理について検討する．

指定したシステム動作モードへの切換えは，次のシステム動作モードを示す変
数（p_nxtsom）を指定したシステム動作モードに設定し，システム周期の基準
時刻を現在時刻（を遅い方に丸めた時刻）に設定した後，システム周期の実行
開始処理（scyc_start）を呼び出す．scyc_startからのリターン後，必要であ
れば，タスク切換えを行う．

ただし，chg_somがディスパッチ保留状態で呼ばれた場合には，scyc_startを
呼び出す代わりに，pending_scycswitchをtrueにする．残りの処理は，ディス
パッチ保留状態が解除された時に行われる．

以上
